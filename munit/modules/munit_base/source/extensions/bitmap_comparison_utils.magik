#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=basic,topic=MUnit)
##  
## A utility class to aid in writing unit tests that need to do
## bitmap comparison of graphical output.
## There is no need to instantiate an instance of this class,
## methods can be invoked on the exemplar.
##
## There is no method to store the expected file prior to
## setting up the test. This can be done easily using the
## following Magik,
##
## data << bitmap_comparison_utils.get_pixel_data(my_mc)
## serial_xml_thing.write_thing_to(data, "my_test_expected.xml")
##
## The only caveat being that the file name and location should
## match the constructed ones in bitmap_comparison_utils.compare()
##
def_slotted_exemplar(:bitmap_comparison_utils, {} )
$

_pragma(classify_level=advanced,topic=MUnit)
_method bitmap_comparison_utils.get_pixel_data(a_memory_canvas)
	##
	## Retrieves the pixel data as a simple vector
	## containing the pixel values. Note that this method is not
	## especially fast, and is dependent on the size (width x
	## height) of the memory_canvas. You should create one that is
	## small as possible.
	##
	## A_MEMORY_CANVAS: the memory canvas on which you wish to
	## perform the comparison. 
	##
	_local w << a_memory_canvas.width
	_local h << a_memory_canvas.height
	_local data << simple_vector.new(w*h)

	_for y _over 0.upto(h-1)
	_loop 
		_for x _over 0.upto(w-1)
		_loop
			data[y*w+x+1] << a_memory_canvas.pixel(x,y)
		_endloop 
	_endloop
	>> data
_endmethod
$


_pragma(classify_level=advanced,topic=MUnit)
_method bitmap_comparison_utils.compare(test_name, actual_data, a_test_case,
					_optional failure_message)
	##
	## Compares the actual data to that stored in a reference file.
	## Performs the assert. If the test case fails then a data file
	## containing the "actual" data is dumped. This can later be
	## interogated using bitmap_comparison_utils.show_test_data()
	##
	## TEST_NAME: a unique string identifying the test case. This is
	## used to construct file name containing the expected
	## bitmap data, and so must be unique for each test in the module.
	## This is used to find an XML file of the name
	## <TEST_NAME>_expected.xml in the resources/base/data
	## directory for the comparison, and will also be used to
	## construct a similar <TEST_NAME>_actual.xml if the
	## test fails.
	##
	## ACTUAL_DATA: the data generated by the test case
	##
	## A_TEST_CASE: the test case performing the test, callers will
	## typically pass in _SELF
	##
	## FAILURE_MESSAGE: the message to display if the test fails. A
	## default message containing the EXPECTED_FILE_NAME is
	## generated if this is not supplied.
	expected_file_name << test_name + "_expected.xml"
	_try 
		file << smallworld_product.get_data_file(expected_file_name, a_test_case.module_name)
		# file in: resources/base/data
	_when resource_not_found_error
		a_test_case.fail("'expected' file " + expected_file_name +
				 " not found in module " + a_test_case.module_name )
	_endtry
	_local expected_data << serial_xml_thing.read_thing_from(file)

	# Do the assert
	a_test_case.assert_deep_equals( actual_data, expected_data,
					failure_message.default("bitmap comparison on " +  expected_file_name + " failed"))
	_if a_test_case.failed?
	_then
		(filename, dir) << system.pathname_components(file)
		actual_file_name <<  system.pathname_down(dir, test_name + "_actual.xml")
		serial_xml_thing.write_thing_to(actual_data, actual_file_name )
	_endif 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method bitmap_comparison_utils.set_pixel_data(pixel_data, w, h)
	## creates a memory canvas containing the data in PIXEL_DATA
	##
	a_memory_canvas << memory_canvas.new(w,h)
	a_memory_canvas.clear()
	_for y _over 0.upto(h-1)
	_loop 
		_for x _over 0.upto(w-1)
		_loop
			a_memory_canvas.pixel(x,y) << pixel_data[y*w+x+1]
		_endloop 
	_endloop
	>> a_memory_canvas
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method bitmap_comparison_utils.show_data(title, pixel_data, w,h, _optional pos)
	##
	## Put up a dialog displaying PIXEL_DATA
	##
	f << frame.new(title)
	f.position << pos
	c << canvas.new(f,w,h)
	c.retained? << _true
	mc << bitmap_comparison_utils.set_pixel_data(pixel_data, w, h)
	f.active? << _true
	_thisthread.sleep(1000)
	c.copy_area(0,0,w,h,mc,0,0)
	>> f
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method bitmap_comparison_utils.difference_data(expected_data,actual_data)
	##
	## Constructs a 'bitmap' containing the differences between the
	## EXPECTED_DATA and the ACTUAL_DATA.
	##
	## Pixels that are the same are painted white, those that are
	## different are painted black.
	diff_data << simple_vector.new(expected_data.size)
	_for i _over 1.upto(expected_data.size)
	_loop
		_if expected_data[i] = actual_data[i]
		_then diff_data[i] << 16777215 # White
		_else diff_data[i] << 0
		_endif 
	_endloop
	>> diff_data
_endmethod
$

_pragma(classify_level=advanced,topic=MUnit)
_method bitmap_comparison_utils.show_test_data(test_name, a_test_case,width,height)
	##
	## Displays dialogs showing the expected, actual and difference bitmaps
	##
	## TEST_NAME: the name of the test. This is used to construct
	## the file names containing the bitmap data
	##
	## A_TEST_CASE: the test_case for this test. This is used to
	## identify the location of the files
	##
	## WIDTH: the width of the bitmap being compared
	##
	## HEIGHT: the height of the bitmap being compared
	##
	expected_file_name << test_name + "_expected.xml"
	actual_file_name << test_name + "_actual.xml"
	_try 
		ex_file << smallworld_product.get_data_file(expected_file_name, a_test_case.module_name)
		act_file << smallworld_product.get_data_file(actual_file_name, a_test_case.module_name)
	_when resource_not_found_error
		_return
	_endtry
	_local expected_data << serial_xml_thing.read_thing_from(ex_file)
	_local actual_data << serial_xml_thing.read_thing_from(act_file)
	
	f1 << bitmap_comparison_utils.show_data("Expected", expected_data,width,height)
	offset << f1.screen_bounds.width
	f2 << bitmap_comparison_utils.show_data("Actual", actual_data,width,height,
						pixel_coordinate.new(f1.x + offset, f1.y))
	offset << f2.screen_bounds.width
	bitmap_comparison_utils.show_data("Difference",
					  bitmap_comparison_utils.difference_data(expected_data, actual_data),
					  width,height,
					  pixel_coordinate.new(f2.x + offset, f2.y) )
					  
_endmethod
$
