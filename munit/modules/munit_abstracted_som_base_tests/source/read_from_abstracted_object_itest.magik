#% text_encoding = iso8859_1
_package sw
$


_pragma(classify_level=restricted)
def_slotted_exemplar (:read_from_abstracted_object_itest,
	{
	},
	{
		:abstracted_object_itest
	})

$

_pragma(classify_level=subclassable)
_abstract _method read_from_abstracted_object_itest.network_builder_insert_method_name
	##
	## Subclasses should implement this
	## Return a method, defined on a network_builder that will be
	## used to create the test data
_endmethod
$

_pragma(classify_level=restricted)
_method read_from_abstracted_object_itest.int!test_read_abstracted_object(test_key)
	
	## test using this test method should populate the
	## .object_test_data slot[TEST_KEY] (a property_list) to provide data to
	## be written into the source model and tests to read through
	## the abstracted model.
	## An example for wire segments is here:
	##	
	##	
	##		.object_test_data[:test_wire_1] << 
	##		property_list.new_with(
	##			# :installation_props, :phases & :asset_phase_props are passed
	##			# to a network_builder API, as defined by :|network_builder_insert_method_name|
	##			:installation_props,
	##			property_list.new_with(:network_type, "MV", :route, pseudo_chain.new_for_world(sector.new_with_xy(1000,0,1000,100000), ev.world)),  #FIXME ev
	##			:phases,
	##			{{"B"}},
	##			:asset_phase_props,
	##			{property_list.new_with(:asset_id, "123")},
	##			:tests, {
	##                                      #- A selector can be defined as a sequence of methods to be
	##                                      #  called on the abstracted object to return an actual result
	##                                      #- An expected_result can be a single value
	##					property_list.new_with(:selector,
	##							       {:network_type},
	##							       :expected_result,
	##							       "MV"
	##							       ),
	##                                      #- An expected_result can be defined as a sequence of methods
	##                                      #  to be called on the newly created object in the source
	##                                      #  view (:source_obj)
	##					property_list.new_with(:selector,
	##							       {:network_type},
	##							       :expected_result,
	##							       {:source_obj, :network_type}
	##							       ),	
	##					property_list.new_with(:selector,
	##							       {:network_type, :|as_symbol()|},
	##							       :expected_result,
	##							       :|MV|
	##							       )
	##			}
	##			      )
	##
	
	#Given - there are some objects 
	_self.write_data_into_source_model(test_key)
	
	#then verify the expected values in the abstracetd object
	_self.check_reading_of_data_through_abstracted_model(test_key)
	
_endmethod
$

_pragma(classify_level=subclassable)
_method read_from_abstracted_object_itest.write_data_into_source_model( test_key, _optional state )
	##
	##	This method can be subclassed for a specific test object
	
_endmethod
$

_pragma(classify_level=restricted)
_method read_from_abstracted_object_itest.check_reading_of_data_through_abstracted_model(test_key _optional abs_coll_name)
	##
	##
	
	_if (tests << .object_test_data[test_key][:tests]) _is _unset
	_then
		_return
	_endif
	
	source_obj << .object_test_data[test_key][:source_obj]
	_self.assert_not_unset(source_obj,
		write_string(test_key, "  No object created in the source model, or cached on the test?")
	)
	
	abstracted_obj << _self.get_abstracted_object_for_source_object(source_obj, abs_coll_name)
	
	_self.assert_true(equality_set.new_from_iter(
			abstracted_obj.source_rwos,
			:|elements()|).includes?(source_obj),
		write_string(test_key, "   abstracted_obj not associated with source_obj - weird!")
	)
	
	_for i_test _over tests.elements()
	_loop
		_if _not i_test.includes_key?(:selector)
		_then
			_self.fail("Test case does not specify :selector")
			_continue
		_endif
		
		_if _not i_test.includes_key?(:expected_result)
		_then
			_self.fail("Test case does not specify :expected_result")
			_continue
		_endif			
		
		selector << i_test[:selector]
		expected_result << i_test[:expected_result]
		
		_if expected_result.class_name _is :simple_vector _andif
			(s << expected_result.size) > 1 _andif
			expected_result[1] _is :source_obj
		_then
			# Instead of a given expected result, we compute it from
			# calling methods on the source object
			expected_result << _self.apply_method_chain_to_object(source_obj, expected_result.slice_to_end(2))
		_endif
		
		# Instead of a given actual result, we compute it from
		# calling methods on the source object
		actual_result << _self.apply_method_chain_to_object(abstracted_obj, selector)
		
		selector_str << internal_text_output_stream.new()
		selector_str.write_list_with_separator(selector, %.)
		
		_self.assert_equals(expected_result, actual_result,
			write_string(test_key, ",field: ", selector_str.string, ", ", expected_result, " <> ", actual_result)
		)
	_endloop
_endmethod
$
