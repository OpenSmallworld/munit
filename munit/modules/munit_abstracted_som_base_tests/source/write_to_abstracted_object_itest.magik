#% text_encoding = iso8859_1
_package sw
$

_pragma(classify_level=restricted)
def_slotted_exemplar (:write_to_abstracted_object_itest,
	{ },
	{:abstracted_object_itest})
$

_pragma(classify_level=restricted)
_method write_to_abstracted_object_itest.int!test_complete_inserts_in_single_transactions(test_key)
	
	##
	## test using test method should populate the
	## .object_test_data slot[TEST_KEY] (a property_list) to provide data to
	## be written into the source model and tests to read through
	## the abstracted model.
	## An example for wire segments is here:
	##	
	##	
	##		.object_test_data[:test_wire_1] << 
	##		property_list.new_with(
	##			# :installation_props, :phases & :asset_phase_props are passed
	##			# to a network_builder API, as defined by :|network_builder_insert_method_name|
	##			:installation_props,
	##			property_list.new_with(:network_type, "MV", :route, pseudo_chain.new_for_world(sector.new_with_xy(1000,0,1000,100000), ev.world)),  #FIXME ev
	##			:phases,
	##			{{"B"}},
	##			:asset_phase_props,
	##			{property_list.new_with(:asset_id, "123")},
	##			:tests, {
	##                                      #- A selector can be defined as a sequence of methods to be
	##                                      #  called on the abstracted object to return an actual result
	##                                      #- An expected_result can be a single value
	##					property_list.new_with(:selector,
	##							       {:network_type},
	##							       :expected_result,
	##							       "MV"
	##							       ),
	##                                      #- An expected_result can be defined as a sequence of methods
	##                                      #  to be called on the newly created object in the source
	##                                      #  view (:source_obj)
	##					property_list.new_with(:selector,
	##							       {:network_type},
	##							       :expected_result,
	##							       {:source_obj, :network_type}
	##							       ),	
	##					property_list.new_with(:selector,
	##							       {:network_type, :|as_symbol()|},
	##							       :expected_result,
	##							       :|MV|
	##							       )
	##			}
	##			      )
	##
	
	#Given
	_self.write_data_into_abstracted_model(test_key)
	#When-then
	_self.check_writing_of_data_through_abstract_model(test_key, :written_abstract_obj)
_endmethod
$

_pragma(classify_level=restricted)
_method write_to_abstracted_object_itest.write_data_into_abstracted_model(test_key)
	##
	##
	
	test_data << .object_test_data[test_key]
	
	test_obj_trans << record_transaction.new_insert(
		.abstracted_view.collections[test_data[:abstracted_table_name]],
		test_data[:table_properties]
	)
	
	test_obj << test_obj_trans.run()
	
	_if test_obj _isnt _unset
	_then
		test_data[:written_abstract_obj] << test_obj
		write("Written ", test_obj, " to the datastore")
	_endif
	
_endmethod
$


_pragma(classify_level=restricted)
_method write_to_abstracted_object_itest.write_string_for_rwo_set(rwos)
	rope_of_rwos << rope.new_from(rwos)
	rope_of_strings << rope_of_rwos.map(_proc (el) _return el.write_string _endproc)
	_return rope_of_strings.join_as_strings(", ")
_endmethod
$


_pragma(classify_level=restricted)
_method write_to_abstracted_object_itest.check_writing_of_data_through_abstract_model(test_key, object_key)
	##
	## OBJECT_KEY is the key to use to get the actual object from .object_test_data[test_key] to verify results on.
	## Possible values - :written_abstract_obj,  :updated_abstract_obj
	##
	
	test_data << .object_test_data[test_key]
	abstracted_obj << test_data[object_key]
	
	_if (tests << test_data[:tests]) _is _unset
	_then
		_return
	_endif
	
	_self.assert_not_unset(abstracted_obj,
		write_string(test_key, "  No object created in the source model, or cached on the test?")
	)
	
	source_obj << abstracted_obj.master_rwo
	
	_self.assert_true(equality_set.new_from_iter(
			abstracted_obj.source_rwos,
			:|elements()|).includes?(source_obj),
		write_string(test_key, "   abstracted_obj not associated with source_obj - weird!")
	)
	
	_for i_test _over tests.elements()
	_loop
		#write_with_spaces("Testing ", _scatter i_test[:actual_result][2])
		
		#expected result
		expected_result << i_test[:expected_result]
		_if expected_result.class_name _is :simple_vector _andif
			(s << expected_result.size) > 1
		_then
			_if expected_result[1] _is :table_properties
			_then
				# Instead of a given expected result, we get it from indexing into the :table_properties
				## used to create the abstract object
				fd << expected_result[2]
				table_prop << test_data[:table_properties][fd]
				
				expected_result << _self.apply_method_chain_to_object(table_prop, expected_result.slice_to_end(3))
				
			_elif expected_result[1] _is :update_table_properties
			_then
				# Instead of a given expected result, we get it from indexing into the :update_table_properties
				## used to create the abstract object
				fd << expected_result[2]
				table_prop << test_data[:update_table_properties][fd]
				
				expected_result << _self.apply_method_chain_to_object(table_prop, expected_result.slice_to_end(3))
				
			_elif expected_result[1] _is :source_obj
			_then
				# Instead of a given expected result, we compute it from
				# calling methods on the source object
				expected_result << _self.apply_method_chain_to_object(source_obj, expected_result.slice_to_end(2))
				
			_elif expected_result[1] _is :abstracted_obj
			_then
				# Instead of a given expected result, we compute it from
				# calling methods on the abstracted object
				expected_result << _self.apply_method_chain_to_object(abstracted_obj, expected_result.slice_to_end(2))
			_endif
		_endif
		
		#actual result
		actual_result << i_test[:actual_result]
		test_key_show_string << i_test[:actual_result][2]
		_if actual_result.class_name _is :simple_vector _andif
			(s << actual_result.size) > 1
		_then
			_if actual_result[1] _is :source_obj
			_then
				# Instead of a given actual result, we compute it from
				# calling methods on the source object
				actual_result << _self.apply_method_chain_to_object(source_obj, actual_result.slice_to_end(2))
				
			_elif actual_result[1] _is :abstracted_obj
			_then
				# Instead of a given actual result, we compute it from
				# calling methods on the abstracted object
				actual_result << _self.apply_method_chain_to_object(abstracted_obj, actual_result.slice_to_end(2))
				
			_elif actual_result[1] _is :table_properties
			_then
				fd << actual_result[2]
				table_prop << test_data[:table_properties][fd]
				
				actual_result << _self.apply_method_chain_to_object(table_prop, actual_result.slice_to_end(3))
			_endif
			_for el _over i_test[:actual_result].slice_to_end(3).elements()
			_loop
				test_key_show_string << test_key_show_string + "." + el.write_string
			_endloop
		_endif
		# allow for 0.001 percent difference when comparing floats
		# unfortunatelly many migration tests are stupidly write_string float
		# numbers in hope it will solve rounding errors. therefore
		# !print_float_precision! should not be higher than 7
		_self.assert_equals(expected_result, actual_result,
			write_string(test_key, ", value check for '", test_key_show_string, "', expected:", expected_result, " <> actual:", actual_result),
			0.00001, _true) 
	_endloop
	
	
_endmethod
$
