#% text_encoding = iso8859_1
_package sw
$

_pragma(classify_level=restricted)
def_slotted_exemplar (:update_abstracted_object_itest,
	{},
	{
		:write_to_abstracted_object_itest
	})

$

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.run_and_verify_update_test(test_key)

	#Given - write via abs to mimic the real use case 
	_self.write_data_into_abstracted_model( test_key )
	
	#When
	_if .object_test_data[test_key][:update_rec] _isnt _unset #
	_then
		#run update Txn
		_self.update_data_in_abstracted_model(test_key)
	_else
		condition.raise(:error, :string, ":update_rec not passed in for running update Tx")
	_endif

	#then
	_self.check_writing_of_data_through_abstract_model( test_key, :updated_abstract_obj )

_endmethod
$

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.update_data_in_abstracted_model( test_key )
	##
	## updates record based on whats passed as value for the the :update_rec
	## the lookup is based on the abstract object 
	## :update_rec = {} is considered as update request for parent abstract object (i.e abstracted installation)
	## :update_rec = {meth1,  meth2,...} is considered as update request for object found by 
	## method chaining using methods passed in. i.e meth1, meth2 on the parent abstract object (i.e abs inst)
	##

	test_data << .object_test_data[ test_key ]
	
	_if (update_rec_val << test_data[:update_rec]).class_name _is :simple_vector 
	_then
		abs_obj << test_data[:written_abstract_obj]
		_if update_rec_val.size _is 0
		_then
			#installation rec update
			update_rec << abs_obj
		_else
			#asset rec update
			update_rec << _self.apply_method_chain_to_object(abs_obj, update_rec_val)
		_endif

	_endif

	update_properties << test_data[:update_table_properties]
	
	result << record_transaction.new_update( update_rec, update_properties ).run()

	
	_if result _isnt _unset
	_then
		test_data[:updated_abstract_obj] << result
		write("Updated ", result, " in datastore.")
	_endif
	
_endmethod
$


########################################## DELETE helpers##########################################

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.int!run_and_verify_delete_test(test_key)

	#Given - write via abs to mimic the real use case 
	_self.write_data_into_abstracted_model( test_key )
	_self.capture_records_to_check_for_deletion(test_key)
	_self.capture_records_to_check_for_retention(test_key)
	
	#When
	_if .object_test_data[test_key][:delete_rec] _isnt _unset #
	_then
		#run delete Txn
		_self.delete_data_in_abstracted_model(test_key)
	_else
		condition.raise(:error, :string, ":delete_rec not passed in for running delete Tx")
	_endif

	#then
	_self.check_deleting_of_data_through_abstract_model( test_key, :deleted_abstract_obj )
_endmethod
$

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.capture_records_to_check_for_retention(test_key)
	test_data << .object_test_data[ test_key ]
	_if test_data[:records_expected_to_remain] _isnt _unset
	_then
		test_data[:records_to_check_for_retention] << rope.new()
		_for el _over test_data[:records_expected_to_remain].fast_elements()
		_loop
			_if el.class_name _is :simple_vector
			_then
				abs_obj << test_data[:written_abstract_obj]
				rec << _self.apply_method_chain_to_object(abs_obj.master_rwo, el)
				rec_info << property_list.new_with(
						    :collection, rec.source_collection,
						    :id, rec.id
							  )
				test_data[:records_to_check_for_retention].add(rec_info)
				# _else  Implement other cases if needed
			_endif
			
		_endloop
	_endif
_endmethod
$
_pragma(classify_level=restricted)
_method update_abstracted_object_itest.capture_records_to_check_for_deletion(test_key)
	test_data << .object_test_data[ test_key ]
	_if test_data[:records_expected_to_be_deleted] _isnt _unset
	_then
		test_data[:records_to_check_for_deletion] << rope.new()
		_for el _over test_data[:records_expected_to_be_deleted].fast_elements()
		_loop
			_if el.class_name _is :simple_vector
			_then
				abs_obj << test_data[:written_abstract_obj]
				rec << _self.apply_method_chain_to_object(abs_obj.master_rwo, el)
				rec_info << property_list.new_with(
						    :collection, rec.source_collection,
						    :id, rec.id
							  )
				test_data[:records_to_check_for_deletion].add(rec_info)
				# _else  Implement other cases if needed
			_endif
			
		_endloop
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.delete_data_in_abstracted_model( test_key )
	##
	## delete record based on whats passed as value for the the :delete_rec
	## the lookup is based on the abstract object 
	## :delete_rec = {} is considered as delete request for parent abstract object (i.e abstracted installation)
	## :delete_rec = {meth1,  meth2,...} is considered as delete request for object found by 
	## method chaining using methods passed in. i.e meth1, meth2 on the parent abstract object (i.e abs inst)
	##

	test_data << .object_test_data[ test_key ]
	
	_if (delete_rec_val << test_data[:delete_rec]).class_name _is :simple_vector 
	_then
		abs_obj << test_data[:written_abstract_obj]
		_if delete_rec_val.size _is 0
		_then
			#installation rec update
			delete_rec << abs_obj
		_else
			#child rec update
			delete_rec << _self.apply_method_chain_to_object(abs_obj, delete_rec_val)
		_endif

	_endif

	test_data[:delete_abstract_obj] << delete_rec #the object intended to be deleted
	write("Going to test delete of object:", delete_rec)

	result << record_transaction.new_delete( delete_rec ).run()

_endmethod
$

_pragma(classify_level=restricted)
_method update_abstracted_object_itest.check_deleting_of_data_through_abstract_model( test_key )
	##
	##

	test_data << .object_test_data[ test_key ]

	# Check the object that we asked to be deleted
	deleted_abstract_obj << test_data[:delete_abstract_obj]
	_self.assert_record_deleted( deleted_abstract_obj.source_collection, deleted_abstract_obj.id )
	_self.assert_record_deleted( deleted_abstract_obj.master_rwo.source_collection, deleted_abstract_obj.id )

	# Check deleted records
	_if test_data[:records_to_check_for_deletion] _isnt _unset
	_then
		_for rec _over test_data[:records_to_check_for_deletion].fast_elements()
		_loop
			_self.assert_record_deleted( rec[:collection], rec[:id] )
		_endloop
	_endif
	# Check remained records
	_if test_data[:records_to_check_for_retention] _isnt _unset
	_then
		_for rec _over test_data[:records_to_check_for_retention].fast_elements()
		_loop
			_self.assert_record_not_deleted( rec[:collection], rec[:id] )
		_endloop
	_endif
_endmethod
$
_pragma(classify_level=restricted)
_method update_abstracted_object_itest.assert_record_deleted( collection, id )
	##
	## Assert that COLLECTION does not contain a record with id ID
	##
	msg << write_string("Collection ", collection, " has record at id ", id)
	_self.assert_unset(collection.at(id), msg)
_endmethod
$
_pragma(classify_level=restricted)
_method update_abstracted_object_itest.assert_record_not_deleted( collection, id )
	##
	## Assert that COLLECTION does contain a record with id ID
	##
	msg << write_string("Collection ", collection, " has not record at id ", id)
	_self.assert_not_unset(collection.at(id), msg)
_endmethod
$
