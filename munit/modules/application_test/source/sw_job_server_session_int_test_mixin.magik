#% text_encoding = iso8859_1
_package sw
$

_pragma(classify_level=debug)
def_mixin(:sw_job_server_session_int_test_mixin, {:json_assert_mixin})
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.tear_down()
	##
	##

	_if (app << smallworld_product.applications.an_element()) _isnt _unset 
	_then
		app.close()
	_endif 

	job_server_framework.job_server.set_types_and_groups(_unset)
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_window_system_is_not_set()
	## 
	##
	
	_self.assert_unset(!window_system!,
			   "!window_system! global value is set while it should be unset.")
	
	_self.assert_equals(system.window_system,
			    :none,
			    "Wrong value of system.window_system: #1")	
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.int!test_logger_is_registered(logger_name)
	## 
	## Check that the log_manager has a logger registered called LOGGER_NAME
	
	fail_str << write_string("log_manager does not have a logger named ", logger_name, " registered.")
	_self.assert_not_unset(log_manager.get_logger(logger_name), fail_str)
	
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_only_one_application_configured_in_session()
	## 
	##
	
	_if (actual << smallworld_product.command_line_options[:application]) _isnt _unset
	_then
		expected << _self.application_name
		fail_str << write_string("Wrong application started. Expected: ", expected, "Actual: ", actual) 
		_self.assert_equals(expected, actual, fail_str)
	_else
		_self.fail("Application is not started.")
	_endif

_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_job_server_is_running()
	##
	##
	
	_self.given_an_application()
	_self.assert_true(job_server_framework.job_server.running?, "Job Server is not running.")

_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_expected_plugins_are_available()
	## 
	##

	_self.given_an_application()
	_if (app << _self.properties[:app]) _isnt _unset
	_then
		_for plugin_name, plugin_class _over _self.expected_plugins.fast_keys_and_elements()
		_loop
			_if (plugin << app.component(plugin_name)) _isnt _unset
			_then
				_self.assert_equals(plugin_class, plugin.class_name,
						    "Plugin " + plugin_name + " is of wrong class: #1")
			_else
				_self.fail("Plugin not available: " + plugin_name)
			_endif
		_endloop
	_else
		_self.fail("Application is not started.")
	_endif
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.given_an_application()
	##
	##

	_if (app << smallworld_product.applications.an_element()) _is _unset 
	_then 
		smallworld_product.application_definition(_self.application_name).start()
		app << smallworld_product.applications.an_element()
	_endif	
	_self.properties[:app] << app

	>> _self

_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_job_server_logger_is_registered()
	##
	##
	
	_self.assert_not_unset(log_manager.get_loggers[:job_server],
			       "Job Server logger is not registered.")
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.given_job_engine_is_stopped()
	##
	##

	job_server_framework.job_server.stop()

	# Wait for the job server to terminate
	_while job_server_framework.job_server.running?
	_loop
		_thisthread.sleep(100)
	_endloop 

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.when_job_engine_is_started()
	##
	##
	
	job_server_framework.job_server.start()

	# Wait for the job server to terminate
	_while _not job_server_framework.job_server.running?
	_loop
		_thisthread.sleep(100)
	_endloop 

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.when_job_engine_is_stopped()
	##
	##
	
	_return _self.given_job_engine_is_stopped()
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.given_test_null_job_in_job_queue()
	##
	##

	stub_method_helper.replace_method(date_time,
					  :|now()|,
					  _proc()
						  _return date_time.new_from_components(2022, 1, 1, _unset,
											12, 0, 0, _unset, _unset)
					  _endproc)

	job << _self.properties[:null_job] << job_server_framework.job_server.create_new_job(:type, :null)

	stub_method_helper.replace_method(job, :ds!version,
					  _proc() _return 123 _endproc)
	stub_method_helper.replace_method(job, :user,
					  _proc() _return "test_user" _endproc)	
	stub_method_helper.replace_method(sw_job_engine, :|get_server_identifier()|,
					  _proc() _return "test_server" _endproc)	

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.when_test_job_is_processed()
	##
	##
	
	# Wait for the job to be processed
	cnt < 0
	_while _not (_self.properties[:null_job].status = "Completed")
	_loop
		_thisthread.sleep(100)
		show(:job_status, _self.properties[:null_job].status)
	_endloop 	

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.then_log_content_is_correct(file_name)
	##
	## FILE_NAME - the file with expected JSON content
	##

	act_json << _self.get_last_four_entries_from_job_server_log_file()
	
	_self.assert_json_file(file_name, act_json, "Log is incorrect: #1")

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.get_last_four_entries_from_job_server_log_file()
	##
	## Gets last four lines from job server log.
	##

	stream << log_manager.get_loggers[:job_server].sys!slot(:logger).sys!slot(:stream)
	stream.sys!slot(:stream).flush()
	current_file << stream.sys!slot(:current_file)
	
	four_lines << rope.new()
	file << external_text_input_stream.new(current_file)
	_protect
		_loop
			line << file.get_line()
			
			_if line _is _unset
			_then
				_leave
			_endif
			
			_if _not line.empty?
			_then
				four_lines.add_last(line)
			_endif

			_if four_lines.size > 4
			_then
				four_lines.remove_first()
			_endif
		_endloop
	_protection
		file.close()
	_endprotect
	
	_return %[ + four_lines.join_as_strings(%,) + %]
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.given_job_engine_types_and_groups(types)
	##
	## 
	
	job_server_framework.job_server.set_types_and_groups(types)

	_return _self
_endmethod
$


_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_job_server_logging()
	##
	## Checks if Job Server logging works fine and writes correct
	## log entries to a log file.
	##

	_self.given_an_application()
	
	_if log_manager.get_loggers[:job_server] _isnt _unset
	_then
		_self.
			given_job_engine_is_stopped().
			given_job_engine_types_and_groups({"null"}).
			given_test_null_job_in_job_queue().
			when_job_engine_is_started().
			when_test_job_is_processed().
			when_job_engine_is_stopped().
			then_log_content_is_correct("log.json")
	_else	
		_self.fail("Job Server logger is not registered.")
	_endif
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_sw_job_server_logging_module_is_loaded()
	##
	##
	
	_self.assert_not_unset(sw_module_manager.module(:sw_job_server_logging).loaded?,
			       "sw_job_server_logging module is not loaded.")
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.assert_json_file(exp_json_fname, actual_json _optional msg _gather sort_data)
	##
	## Changes module name that is used for getting resource files.
	##
	(str, filename) << _self.resource_file_as_string(exp_json_fname,
							 _unset,
							 sw_job_server_session_int_test_mixin.module_name)
	_self.last_expected_file_path << filename
	>> _self.assert_json(str, actual_json, msg, _scatter sort_data)
_endmethod
$
