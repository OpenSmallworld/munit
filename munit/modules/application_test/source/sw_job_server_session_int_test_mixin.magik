#% text_encoding = iso8859_1
_package sw
$

_pragma(classify_level=debug)
def_mixin(:sw_job_server_session_int_test_mixin, {})
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_window_system_is_not_set()
	## 
	##
	
	_self.assert_unset(!window_system!,
			   "!window_system! global value is set while it should be unset.")
	
	_self.assert_equals(system.window_system,
			    :none,
			    "Wrong value of system.window_system: #1")	
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.int!test_logger_is_registered(logger_name)
	## 
	## Check that the log_manager has a logger registered called LOGGER_NAME
	
	fail_str << write_string("log_manager does not have a logger named ", logger_name, " registered.")
	_self.assert_not_unset(log_manager.get_logger(logger_name), fail_str)
	
_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.test_application_is_started()
	## 
	##

	actual   << app.application_name
	_if (app << smallworld_product.applications.an_element()) _isnt _unset
	_then
		expected << _self.application_name
		fail_str << write_string("Wrong application started. Expected: ", expected, "Actual: ", actual) 
		_self.assert_equals(expected, actual, fail_str)
	_else
		_self.fail("Application ", actual, " is not started.")
	_endif

_endmethod
$

_pragma(classify_level=debug)
_method sw_job_server_session_int_test_mixin.int!test_expected_plugins_are_available(expected_plugins)
	## 
	##

	_if (app << smallworld_product.applications.an_element()) _isnt _unset
	_then
		_for plugin_name, plugin_class _over expected_plugins.fast_keys_and_elements()
		_loop
			_if (plugin << app.component(plugin_name)) _isnt _unset
			_then
				_self.assert_equals(plugin_class, plugin.class_name,
						    "Plugin " + plugin_name + " is of wrong class: #1")
			_else
				_self.fail("Plugin not available: " + plugin_name)
			_endif
		_endloop
	_else
		_self.fail("Application is not started.")
	_endif
_endmethod
$
