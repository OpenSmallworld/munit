#% text_encoding = iso8859_1
_package sw
$

_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
##
## A class that sets up a Design and Project to perform Munit testing.
##
## Tests should provide subclasses.In subclasses the
## checkpoint_name, project_name and design_name shared
## constants should be set.  
##
## You need to define the extent for the project area: subclass
## and redefine the shared constants: start_coord and
## :data_bounds_size
##
## Subclasses can also redefine the writable_design_name - this
## is the name of the state to which the design should be
## transitioned in order to make it writable.
##
## If the test will make use of cost objects, you can choose to
## load a CO dump file. There are two constants to control the
## behaviour: 
## - if there are COs to load, then place the file in the
## resources\base\data folder of the tests module and configure
## the constant :cu_config_file_to_load with the file name
## - you can choose to load the CO direct into the top
## alternative or into a special test named alternative of the
## design_config view. The view is committed after loading. If
## the constant :co_load_test_alternative_name returns a
## string, then an alternative with this name is created and
## used. If this constant is unset then the top alternative is
## used. 
## 
def_slotted_exemplar( :design_manager_test_case,
	{
		{:bounds, _unset},
		{:rwo_set, _unset},
		{:default_world,_unset},
		{:properties, _unset}
	},
	{ :test_case, :design_manager_system_test_mixin })
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## Coordinate used as starting point for Design area. The
## design extent will be centred on this coordinate.
design_manager_test_case.define_shared_constant( :start_coord, coordinate.new( 0, 0 ), :public )
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## Size used to define the extent of the design area.
design_manager_test_case.define_shared_constant( :data_bounds_size, 10000, :public )
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## Checkpoint name for one time setup
design_manager_test_case.define_shared_constant( :checkpoint_name, :one_time_setup_complete, :public )
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## The status to transition the design to to ensure that it is writable
## This implementation defaults to the ups_demo_db state model
design_manager_test_case.define_shared_constant( :writable_design_status, "Design Layout", :public )
$



_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## The name of a CO dump file which should defines any COs
## required for this test. The file should be located in the
## resources\base of the tests module
design_manager_test_case.define_shared_constant( :cu_config_file_to_load,_unset,:public)
$

_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
## Identifies the name of an alternative in the design_config
## partition into which any test specific COs will be loaded.
## If unset then defaults to top.
design_manager_test_case.define_shared_constant( :co_load_test_alternative_name,_unset,	:public)
$


_pragma(classify_level=restricted,topic=MUnit,usage=subclassable)
## Specifies whether the design tab should respond to change
## notification.
## Turning off the design tab's change handling should speed up
## the test.
## Defaults to _false (i.e. the design tab won't update during
## the test).
design_manager_test_case.define_shared_constant(:design_tab_updates_required?, _false, :private)
$


_pragma(classify_level=debug,topic={MUnit, Test})
## Specifies whether any designs created while running a test are kept or deleted
## By default, designs are deleted, setting this to true will allow you to look
## at the data to help develop tests.
## This should only be set to true during development.
design_manager_test_case.define_shared_variable(:keep_designs?, _false, :public)
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.properties
	## 
	##

	>> .properties 
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.set_up()
	## 
	##

	.properties << property_list.new()

	_if _not _self.design_tab_updates_required?
	_then
		stub_method_helper.replace_method(dm!design_tab_framework, :|note_change()|, _proc() _endproc)
	_endif
	
	_super.set_up()
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.init( a_name )
	##
	## Defines slot values
	##

	_super.init( a_name )

	.bounds << _self.start_coord.bounds.extended_by( _self.data_bounds_size )
	.properties << property_list.new()
	
	>> _self
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_private _method design_manager_test_case.project_name
	##
	## DM project name for this test. Defaults to test class name.
	##
	>> _self.class_name.write_string
_endmethod 
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.design_name
	##
	## Default design name based on class name
	##

	design_name << _self.class_name()

	_if design_name.size > 64
	_then
		design_name << design_name.slice( 1, 64 )
	_endif

	>> design_name
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.sub_design_name( parent_design )
	##
	## Default sub-design name based on  user_name + host_name + parent_design_id
	##
	## User name is obtained from system.getenv("TEST_USER") if
	## set and non-empty, otherwise from system.user_name
	##
	## This creates a unique design name based on user and image so
	## that tests can be run in parallel without read/write
	## conflicts.
	##
	
	test_user << system.getenv( "TEST_USER" )
	_if test_user _is _unset _orif
	    test_user = ""
	_then
		test_user << system.user_name
	_endif

	design_name << write_string( test_user, %@, system.host_name, %_, parent_design.key_value().an_element())
	
	_if design_name.size > 64
	_then
		design_name << design_name.slice ( 1, 64 )
	_endif

	>> design_name
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.class_name()
	## 
	## Return self.class_name.  This is a customization hook.
	##

	>> _self.class_name
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.ds_views
	##
	## Views attached to design
	## Subclassed to restrict views to those specified by the test class
	##
	
	ds_views << property_list.new()
	
	_for i_v_name _over _self.ds_view_names.fast_elements()
	_loop
		_if (a_view << gis_program_manager.databases[i_v_name]) _isnt _unset
		_then
			ds_views[i_v_name] << a_view
		_endif
		
	_endloop 
	
	_return ds_views
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.one_time_set_up()
	## 
	##
	
	_if swg_dsn_admin_engine.view _is _unset
	_then
		swg_dsn_admin_engine.init()
	_endif

	_super.one_time_set_up()
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.one_time_tear_down()
	## 
	##

	swg_dsn_admin_engine.activate_design( _unset )
	_super.one_time_tear_down()
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.tear_down()
	## 
	##
	
	_self.delete_child_design()
	_super.tear_down()
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_method design_manager_test_case.delete_child_design( _optional design_key )
	## 
	##

	_if design_key _is _unset _then design_key << :child_design _endif

	_if ( child_design << .properties[ design_key ]) _isnt _unset _andif
	    child_design.is_valid?
	_then
		_if swg_dsn_admin_engine.active_scheme = child_design
		_then
			swg_dsn_admin_engine.activate_scheme( _unset )
		_endif

		_self.int!delete_state_history_for(child_design)
		swg_dsn_admin_engine.delete_scheme( child_design )
		.properties[ design_key ] << _unset 
	_endif
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_method design_manager_test_case.run_bare()
        ## Runs the bare test sequence

	# Bug needs refactor, see tc_eo_cim_mapping.run_bare() for details
	
	# Disable database notifications.
	_dynamic !notify_database_data_changes?!
	_local old_value << !notify_database_data_changes?!
	!notify_database_data_changes?! << _false

	_self.stub_map_rendering_if_required()

        _self.one_time_behaviour()

        _protect
		_self.set_up()
		_self.setup_design()
		_self.setup_sub_design()
                _self.run_test()
        _protection
                _self.teardown_design()
		_self.tear_down()
		!notify_database_data_changes?! << old_value 
        _endprotect
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.setup_design()
	##
        ## Setup design
	##

	# Ensure we don't have a design open before we start.
	# If we don't have an open design, this call should be fairly
	# cheap.
	sub_design << _self.sub_design()
	correct_design? << swg_dsn_admin_engine.active_scheme = sub_design _andif
			   sub_design _isnt _unset 
	_if _not correct_design?
	_then 
		swg_dsn_admin_engine.clear_current_design()
	_endif

	# Ensure that we are looking at fresh design_admin view
	swg_dsn_admin_engine.rollforward()
	
	design << _self.get_existing_test_design( _self.project_name, _self.design_name )
	_if design _isnt _unset
	_then
		_if _not correct_design?
		_then 
			_self.goto_test_design()
			
			_if _self.one_time_setup_failed?()
			_then
				#debug write(_self, ": re-create design")
				# Either we've never created data in here or the data is out of
				# date. 
				# In either case, it's safer to delete the current design and
				# start again
				swg_dsn_admin_engine.clear_current_design()
				_self.delete_test_design()
				_self.goto_test_design()
				_self.setup_checkpoints_and_data()
			_else
				#debug write(_self, ": goto design")
				# The correct data already exists, so we just need to go back
				# to the correct checkpoint - we go there readonly
				_self.goto_test_checkpoints( "", _true )
			_endif
		_else 
			.properties[:design] << sub_design
		_endif
	_else
		#debug write(_self, ": create design")
		# The design doesn't exist so we create it and add the data and
		# checkpoints
		_self.goto_test_design()
		_self.setup_checkpoints_and_data()
	_endif
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.goto_test_design( _optional design_name )
	## 
	##
	
	_if design_name _is _unset
	_then 
		design_name << _self.design_name
	_endif
	
	_self.given_a_design( _self.project_name, design_name, .bounds.xmin, .bounds.ymin, .bounds.xmax, .bounds.ymax )
	
	>> .properties[ :design ]
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_method design_manager_test_case.setup_sub_design()
	## Setup sub design
	## 

	( sub_design, sub_design_name ) << _self.sub_design()
	sub_design_existed? << sub_design _isnt _unset
	
	# go to test sub design where test will run (create it if it doesn't exist)
	_if sub_design_existed?
	_then
		swg_dsn_admin_engine.activate_design( sub_design )
		# go to state test run
		_self.goto_test_checkpoints()
		_self.properties[ :design  ] << sub_design		
	_else
		_self.given_a_new_design( _self.project_name, sub_design_name )
		sub_design << .properties[ :design ]

		# save database state before test is run
		_self.create_test_checkpoints()	
	_endif

	# make sure we have writable access before we run test
	_self.check_writable_access( sub_design )
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.sub_design()
	## 
	##

	parent_design << _self.get_existing_test_design( _self.project_name, _self.design_name )
	_if parent_design _isnt _unset
	_then 
		sub_design_name << _self.sub_design_name( parent_design )
		sub_design      << _self.get_existing_test_design( _self.project_name, sub_design_name )
	_endif

	>> ( sub_design, sub_design_name )
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.one_time_setup_failed?( _optional prefix )
	##
        ## Check if we've done already database setup
	##

	_for ds_view _over _self.ds_views.fast_elements()
	_loop 
		_if _not ds_view.has_checkpoint?( prefix.default( "" ) + _self.checkpoint_name )
		_then
			_return _true
		_endif
	_endloop
	
	>> _false
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.create_test_checkpoints( _optional prefix )
	##
        ## Create databases checkpoints
	##

	_local l_checkpoint_name << prefix.default( "" ) + _self.checkpoint_name
	_for a_ds_view _over _self.ds_views.fast_elements()
        _loop
                a_ds_view.checkpoint( l_checkpoint_name )
        _endloop 
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.goto_test_checkpoints( _optional prefix, readonly? )
	##
        ## Goto databases checkpoints
	##

	_local l_checkpoint_name << prefix.default( "" ) + _self.checkpoint_name
	_local mode << _if readonly? _is _true _then >> :readonly _else >> :write _endif
	
	_for ds_view _over _self.ds_views.fast_elements()
        _loop
		ds_view.go_to_checkpoint( l_checkpoint_name, mode )
		_if ds_view.alternative_level > 1
		_then
			ds_view.checkpoint( l_checkpoint_name )			
		_endif
        _endloop 
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.rollback()
	##
	## Rollback changes in every view we're interested in.
	##
	
	_if _self.keep_designs?
	_then 
		write("Keeping Designs")
	_else 
		_for a_ds_view _over _self.ds_views.fast_elements()
		_loop
			a_ds_view.rollback()
		_endloop
	_endif
	
_endmethod
$

_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.teardown_design()
	##
	## Tear down the design.
	##
	## This just rolls back the changes in every view we're
	## interested in
	## 
	
	_self.rollback()
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.activate_design( p_design )
	##
	## DESCRIPTION:
	## Activates P_DESIGN and ensures status is "In Design"
	## ARGUMENTS ( - <name>: <class>; <description> ):
	## -P_DESIGN; swg_dsn_scheme
	##

	swg_dsn_admin_engine.activate_design( p_design )

	_self.when_changing_design_status( _self.writable_design_status )
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.setup_checkpoints_and_data()
	##
	## Set up the checkpoints and data in the current alternative
	##

	design << _self.get_existing_test_design( _self.project_name, _self.design_name )
	_self.check_writable_access( design )

	write("Loading data to design")
	#save database state before
	_self.create_test_checkpoints("pre_")
	
	#do changes
	_self.one_time_setup_database()
	
	#save database state after
	_self.create_test_checkpoints()	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit,usage=subclassable)
_private _method design_manager_test_case.one_time_setup_database()
	##
        ## Subclass this method if test case requires database to be
        ## updated prior to design creation.
	##
	
_endmethod
$


_pragma(classify_level=debug,topic=MUnit)
_private _method design_manager_test_case.delete_test_design()
	##
	## Delete the test design if it exists
	##
	
	swg_dsn_admin_engine.activate_design( _unset )
	design << _self.get_existing_test_design( _self.project_name, _self.design_name )
	_if design _isnt _unset
	_then
		write( "Deleting design" )
		swg_dsn_admin_engine.delete_scheme( design )
	_endif
_endmethod
$


_pragma(classify_level=debug, topic={Munit})
_private _method design_manager_test_case.check_writable_access( design )
	##
	## Assert the following conditions:
	##
	## 1. DESIGN is the active design
	## 2. The active design is writable
	##
	
	scheme << swg_dsn_admin_engine.active_scheme
	wrong_scheme_msg << _if scheme _is _unset
			    _then
				    >> "no design is active."
			    _else
				    >> write_string( "the design ", scheme.name, " is active." )
			    _endif
	
	desc << write_string( "Expected the design ", design.name,
			      " to be active. However, ", wrong_scheme_msg )
	_self.assert_equals( design, scheme, desc )
	
	_if scheme _isnt _unset _andif scheme _is design
	_then
		( ac_mode, act_read_reason, act_read_reason_msg ) << swg_dsn_admin_engine.activated_mode_for( scheme )

		desc << write_string( "Unable to get write access to the design ", scheme.name, ". ",
				      "Instead, the access mode was ", ac_mode, ". ",
				      "Failed to get write access because ", act_read_reason_msg )
		_self.assert_is( :write, ac_mode, desc )
	_endif
_endmethod
$



_pragma(classify_level=restricted)
_private _method design_manager_test_case.setup_design_config_view()
	##
	## Some tests may not need any specific data and can run in
	## top. Other tests may want to load specific data in top and
	## the final case would be tests that want to load specific
	## data into a named alternative in the design config view.
	##
	## If the test class has the constant
	## _self.co_load_test_alternative_name defined, then an
	## alternative with this name will be used, else top.

	_local ds_config_view << cost_object_library.design_config_view
        
	ds_config_view.goto_top_alternative()

	_if _self.co_load_test_alternative_name _isnt _unset
	_then 
		
		_if _not ds_config_view.has_alternative?(_self.co_load_test_alternative_name)
		_then 
			ds_config_view.create_alternative(_self.co_load_test_alternative_name)
		_endif

		write("Using design config alternative for  COs: ", _self.co_load_test_alternative_name )
		ds_config_view.go_to_alternative(_self.co_load_test_alternative_name)
	_endif
	
_endmethod
$

_pragma(classify_level=restricted)
_private _method design_manager_test_case.load_required_cos()
	##
	## If the test has specific COS defined by a CO dump file in
	## the modules resources\data folder and specified by
	## self.co_dump_file_name, then the file will be imported.
	## The COs will be imported into the design config view - see
	## setup_design_config_view() for details of alternatives

	_if _self.cu_config_file_to_load _isnt _unset _andif
	    _self.module_name _isnt _unset
	_then
		_self.setup_design_config_view()
		ds_config_view << cost_object_library.design_config_view		
		module << sw_module_manager.module( _self.module_name )
		_try
			co_file << module.get_resource_file(_self.cu_config_file_to_load,"data" )
			ds_config_view.switch(:write)
			_self.load_co_dump()
			ds_config_view.commit()

			# refresh the CO cache
			_self.refresh_cost_object_library()
			
		_when resource_not_found_in_module_error
			write("Failed to find named CO dump file ", _self.cu_config_file_to_load  )
		_endtry
	_endif
	
_endmethod
$

_pragma(classify_level=restricted)
_private _method design_manager_test_case.refresh_cost_object_library()
	##
	## Reset CO caches after change to the config view.
	##
         cost_object_library.reset_interested_collections()
         cost_object_library.reset_co_writable_and_logical_fields()
         cost_object_library.reset_cos_for_rwo()
         cost_object_library.reset_cached_cos()
_endmethod
$

_pragma(classify_level=debug)
_private _method  design_manager_test_case.load_co_dump()
        ## 
        ## Load Cos from resource file
        ##
        
        _local co_dump_path << smallworld_product.get_resource_file(_self.cu_config_file_to_load, "data", _self.module_name)
        
        _local (filename, directory)<< system.pathname_components(co_dump_path)
        _local co_load_errors << system.pathname_from_components("CO_CONFIG_LOAD_ERRORS.txt", directory)
        
        stub_method_helper.replace_method(dw!cu_config_loader_engine, :|error_log_file_name|,
                                          _proc()
                                                  _import co_load_errors
                                                  _return co_load_errors
                                          _endproc )

	write("Loading COs from: ", co_dump_path )
	
	dw!cu_config_loader_engine.do(co_dump_path)
	_self.write_cu_loader_error_log_to_console(co_load_errors)
	system.unlink(co_load_errors,_true, _true)
        
_endmethod
$

_pragma(classify_level=debug)
_private _method design_manager_test_case.write_cu_loader_error_log_to_console(fname)
	## 
	## 
	write("dw!cu_config_loader_engine error log file:")
	f << external_text_input_stream.new(fname)
	_protect
		write("-START")
		_loop
			_if (l << f.get_line()) _is _unset
			_then
				_leave
			_endif
			write("- ", l)
		_endloop
	_protection
		f.close()
		write("-END")
	_endprotect
_endmethod
$


_pragma(classify_level=debug, topic={munit})
_method design_manager_test_case.given_a_design_phase(phase_id, _gather attrs)
	## 
	## See swg_dsn_admin_engine.create_build_phase()
	##
	## ATTRS is a list of key/value pairs that is passed to the
	## engine.
	##
	## The phase's name will be PHASE_ID.  If the
	## .properties[:design] already have a phase with this name,
	## this one is used, else a new phase is inserted into the
	## database. 
	##

	name << phase_id.write_string
	pred << predicate.eq(:name, name)
	
	_if (design_phase << .properties[:design].build_phases.select(pred).an_element()) _is _unset
	_then 
		write( "Creating design_phase ", name )
		attrs << property_list.new_from_gathered(attrs)
		design_phase << swg_dsn_admin_engine.create_build_phase(.properties[:design], name, attrs)
	_else 
		write( "Use existing design_phase ", name )
	_endif
	.properties[phase_id] << design_phase

	_if .properties[:phases] _is _unset
	_then
		.properties[:phases] << set.new()
	_endif
	.properties[:phases].add( design_phase )
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug, topic={munit})
_private _method design_manager_test_case.delete_design_phases( _gather phases )
	## 
	## Delete design phases in PHASES
	## If empty, delete all design phases
	##

	phases_to_delete << _if phases.empty?
			    _then
				    >> .properties[:phases].default( {} )
			    _else
				    >> phases
			    _endif 

	_for a_phase _over phases_to_delete.fast_elements()
	_loop
		swg_dsn_admin_engine.delete_build_phase( a_phase )
	_endloop 
	
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.given_compatible_unit_definition_with_code( cu_code )
	##
	## Looks up CO with code CU_CODE and caches in .properties
	## using key cu_code as a symbol. 

	>> _self.int!given_co_definition_with_code( cu_code, :compatible_unit )
	
_endmethod
$


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.given_macro_assembly_definition_with_code( ma_code )
	##
	## Looks up MA with code MA_CODE and caches in .properties
	## using key ma_code as a symbol.  

	>> _self.int!given_co_definition_with_code( ma_code, :macro_assembly)

_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_private _method  design_manager_test_case.int!given_co_definition_with_code( co_code, type)
	##
	## CO_CODE is the code of the cost object definition
	## TYPE is either :compatible_unit or :macro_assembly
	## 

	cu_def <<  cost_object_library.get_for_code(co_code,type)

	_if cu_def _is _unset
	_then
		_self.load_required_cos()
	_endif
	
	cu_def <<  cost_object_library.get_for_code(co_code,type)
	
	_self.assert_not_unset( cu_def , write_string( type.write_string.uppercase, " not found: ", co_code ) )

	.properties[co_code.as_symbol()] << cu_def
	
	>> _self 
	
_endmethod


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.rwo(p_rwo_name)
	##
	## Returns the record that is cached with name RWO_NAME

	_local l_rwo << .properties[p_rwo_name]
	_self.assert_not_unset( l_rwo, write_string("Cannot find RWO: ", p_rwo_name) )

	>> l_rwo
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.cu(cu_name)
	##
	## Returns the record that is cached with name CU_NAME

	_local l_cu << .properties[cu_name.as_symbol()]
	_self.assert_not_unset( l_cu, write_string("Cannot find CU: ", cu_name) )

	>> l_cu
_endmethod
$


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.when_cu_is_added_to_design( library_co_name, _optional rwo_name,
							     point_span_rec, design_status, operation, overrides )

	## Test case wrapper around cost_object_library.add_to_design()
	## LIBRARY_CO_NAME - is the name of a CO definition that has
	## been cached in a previous test step and is looked up by
	## name. It must refer to a 
	## macro_assembly_definition, compatible_unit_definition or a
	## dw!compatible_unit_record that references a library_co
	##
	## RWO_NAME is the name used to previously cache the rwo to
	## which the CO will be associated
	##
	## See cost_object_library.add_to_design() for description of
	## other arguments.
	##
	## The new created CO is cached in .properties[:last_added_co]
	##
	## Returns: self, arguments returned from cost_object_library.add_to_design()

	_dynamic !current_application!

	_if !current_application! _is _unset
	_then
		!current_application! << _self.properties[:application]
	_endif 
	
	_local library_cu << _self.cu( library_co_name.as_symbol() )
	_local l_rwo << _self.rwo( rwo_name )

	co_rec << co_rec << dw!compatible_unit_record.new( library_cu.code, 1,
							   :work_record_name, "Munit WP") 
	
	(new_co,rwos) << cost_object_library.add_to_design( co_rec, l_rwo, point_span_rec, 
							    design_status, operation.default(:install), overrides )
	.properties[:last_added_co] << new_co

	_return _self 
	
_endmethod
$


_pragma(classify_level=restricted)
_method design_manager_test_case.when_creating_child_design( child_design_name )
	##
	## Store the current design in .properties[ :parent_design ]
	## Commit all the changes in the current design
	## Delete the sub design if it exists
	## Create a new sub design
	## Activate the new design
	##

	_self.properties[ :parent_design ] << swg_dsn_admin_engine.active_scheme

	swg_dsn_admin_engine.save_design_changes()

	design_name  << write_string( child_design_name, "-", system.host_name )
	_if ( child_design << _self.get_existing_test_design( _self.project_name, design_name )) _isnt _unset
	_then
		swg_dsn_admin_engine.delete_scheme( child_design )
	_endif
	
	_self.given_a_design( _self.project_name, design_name )

	.properties[ :child_design ] << swg_dsn_admin_engine.active_scheme
	.properties[ child_design_name.as_symbol() ] << .properties[ :child_design ]

	>> _self
	
_endmethod
$


_pragma(classify_level=restricted)
_method design_manager_test_case.when_going_to_parent_design()
	## 
	##

	>> _self.when_going_to_design( .properties[ :parent_design ], "child" )
	
_endmethod
$


_pragma(classify_level=restricted)
_method design_manager_test_case.when_going_to_child_design( _optional design_key )
	## 
	##

	_if design_key _is _unset _then design_key << :child_design _endif 
	>> _self.when_going_to_design( .properties[ design_key ], "child" )
	
_endmethod
$


_pragma(classify_level=restricted)
_method design_manager_test_case.when_going_to_design( design, design_identifier )
	## 
	## 

	fail_str << write_string( "No ", design_identifier, " design to go to" )
	_self.assert_not_unset( .properties[ :child_design ], fail_str )

	swg_dsn_admin_engine.activate_scheme( design )

	fail_str << write_string( "Failed to go to ", design_identifier, " design" )
	_self.assert_equals( design, swg_dsn_admin_engine.active_scheme, fail_str )

	>> _self
	
_endmethod
$


_pragma(classify_level=restricted)
_method design_manager_test_case.when_deleting_design( design )
	## 
	##

	swg_dsn_admin_engine.delete_scheme( design )
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_test_case.when_merging_design( _optional design )
	## 
	##

	_if design _is _unset
	_then
		design << swg_dsn_admin_engine.active_scheme
	_endif

	fail_str << "The swg_dsn_admin_engine.merge_scheme() method is stubbed out to (most likely) do nothing"
	_self.assert_false(stub_method_helper.method_stubbed?(swg_dsn_admin_engine, :|merge_scheme()|, fail_str))
	
	swg_dsn_admin_engine.merge_scheme( property_list.new(), design )
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_test_case.when_i_split_the_linear_rwo_by_trail(id, coords)
	##
	## Splits the route of the linear rwo cached as ID by a "trail"
	## defined by COORDS.  The rwo must have a route geometry field.
	##
	
	_dynamic !current_coordinate_system!
	
	_local rwo  << .properties[id]
	_local geom << rwo.route
	!current_coordinate_system! << rwo.source_view.world.coordinate_system
	
	_local split_sr << sector_rope.new_with(sector.new_with(_scatter coords))
	
	_local rt << custom_record_transaction.new(geom.dataset, geom,
						   :|split_with_sectors()|,
						   {split_sr},
						   "Test split by trail")
	
	rt.run()
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_test_case.when_activating_design_phase(phase_id)
	## 
	##

	design_phase << .properties[phase_id]
	swg_dsn_admin_engine.activate_design(design_phase)
	>> _self
	
_endmethod
$


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_rwo_has_co_in_current_design( rwo_name, cu_name )
	##
	## Asserts that the rwo with RWO_NAME has an assoicated CU CU_NAME
	##

	found? << _self.rwo_associated_with_cost_object?( rwo_name, cu_name, :active_scheme )

	_self.assert_true( found?, write_string( rwo_name, " is not associated with CU ", cu_name ))

	>> _self
	
_endmethod 	
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_all_rwos_with_name_have_co_in_current_design( rwo_name, co_name )
	##
	## Checks that all known rwos with rwo_name have the associated CO_NAME
	## RWO must be known via self.rwo(rwo_name) - but in the case
	## this has been replicated eg by splitting, will find ALL rwos
	## with that name

	rwo << _self.rwo( rwo_name )

	all_rwos << rwo.source_collection.select( predicate.eq(:name,rwo_name.write_string) )

	_for an_rwo _over all_rwos.fast_elements()
	_loop
		
		found? << _false 
		attached_cos << design_cost_item.get_for_record_and_scheme(an_rwo, swg_dsn_admin_engine.active_scheme, :co )
		_for co _over attached_cos.fast_elements()
		_loop
			_if co.code = co_name
			_then
				found? << _true
			_endif
		_endloop

		_self.assert_true( found?, write_string("CO ", co_name, " not found on ", an_rwo ) )
	_endloop
			
	_return _self	

_endmethod
$


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_rwo_does_not_have_co_in_current_design( rwo_name, cu_name )
	##
	## Asserts that the rwo with RWO_NAME has an assoicated CU CU_NAME
	##

	found? << _self.rwo_associated_with_cost_object?( rwo_name, cu_name, :active_scheme  )

	_self.assert_false( found?, write_string( rwo_name, " is associated with CU ", cu_name, " when it should not be" ))

	>> _self
	
_endmethod 	
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_rwo_has_co_in_any_design( rwo_name, cu_name )
	##
	## Asserts that the rwo with RWO_NAME has an assoicated CU CU_NAME
	##

	found? << _self.rwo_associated_with_cost_object?( rwo_name, cu_name, :all )

	_self.assert_true( found?, write_string( rwo_name, " is not associated with CU ", cu_name ))

	>> _self
	
_endmethod 	
$


_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_rwo_does_not_have_co_in_any_design( rwo_name, cu_name )
	##
	## Asserts that the rwo with RWO_NAME has an assoicated CU CU_NAME
	##

	found? << _self.rwo_associated_with_cost_object?( rwo_name, cu_name, :all )

	_self.assert_false( found?, write_string( rwo_name, " is associated with CU ", cu_name, " when it should not be" ))

	>> _self
	
_endmethod 	
$


_pragma(classify_level=debug,topic={MUnit, Test})
_private _method design_manager_test_case.rwo_associated_with_cost_object?( rwo_name, co_name, _optional which_schemes )
	## Returns TRUE if the named RWO is associated with the named CU
	##
	## RWO_NAME is used to look up the cached rwo to test
	## CU_NAME is used to look up the cached CO
	## WHICH_SCHEMES defines the scope of COs of interest:
	## :active_scheme, :all. Default to :active_scheme

	co  << _self.cu( co_name )
	rwo << _self.rwo( rwo_name )

	_if which_schemes _is :all
	_then
		attached_cos << design_cost_item.get_for_record_and_scheme(rwo, _unset, :co )
	_else 
		attached_cos <<  design_cost_item.get_for_record_and_scheme(rwo, swg_dsn_admin_engine.active_scheme, :co )
	_endif 

	found? << _false
	_for co _over attached_cos.fast_elements()
	_loop
		_if co.code = co_name
		_then
			found? << _true
			_leave
		_endif
	_endloop

	>> found?
	
_endmethod
$

_pragma(classify_level=debug, topic={swg_design})
_method design_manager_test_case.given_transition_history(_gather states)
	##
	## Add state history for the design to match STATES
	##
	scheme << _self.properties[ :design  ]

	_for from, to _over _self.adjacent_pairs( states )
	_loop
		swg_dsn_state_history.insert_record( scheme, from, to )
	_endloop

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_private _iter _method design_manager_test_case.adjacent_pairs(list)
	##
	## Yield adjacent pairs of elements from LIST.
	##
	## For example, if list is {:a, :b, :c, :d}, yield the pairs
	##  :a, :b
	##  :b, :c
	##  :c, :d
	##
	first << list[1]
	_for index _over range( 2, list.size )
	_loop
		second << list[index]
		_loopbody( first, second )
		first << second
	_endloop
_endmethod
$


_pragma(classify_level=debug,topic={MUnit, Test})
_private _method design_manager_test_case.int!delete_state_history_for(scheme)
	## 
	##
	
	_if (recs << swg_dsn_state_history.history_for( scheme )) _isnt _unset
	_then
		_for rec _over recs.fast_elements()
		_loop
			record_transaction.new_delete( rec ).run()
		_endloop
	_endif

	# In the case where this design and any of its sub designs has
	# been published, the delete will fail, so state transition
	# history is cleared out before any deletion
	_for sub_scheme _over scheme.sub_schemes.fast_elements()
	_loop
		_self.int!delete_state_history_for(sub_scheme)
	_endloop
	
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.then_expected_number_of_work_points_is( number, _optional a_scheme, description )
	##
	## Validate that the count of workpoints equals NUMBER
	## If a_scheme is provided, then validate the count of
	## workpoints for that scheme equals NUMBER
	## DESCRIPTION is a string appended to the error message if the
	## assert fails - to help diagnose 

	_local num_wps
	
	_if a_scheme _is _unset
	_then
		num_wps << dw!scheme_wp.table.size
	_else
		num_wps << cost_object_library.workpoint_get_for_scheme( a_scheme )
	_endif

	error_message << write_string( "Expected ", number, " workpoints, but found ", num_wps, " ", description.default(""))

	_self.assert_equals( number, num_wps, error_message )
	
	>> _self 
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method design_manager_test_case.given_a_new_co_added_to_design_from_definition( co_code, new_co_name, _optional wp_name )
	##
	## Create a new MA or CU froom the definition given by CO_CODE
	## and cache it with name NEW_CO_NAME.
	## WP_NAME defines the name of the work point to create

	co_rec << co_rec << dw!compatible_unit_record.new( co_code, 1,
							   :work_record_name, wp_name.default("Munit WP") ) 
	
	(new_co,rwos) << cost_object_library.add_to_design( co_rec )

	.properties[new_co_name.as_symbol()] << new_co
	
	>> _self
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method design_manager_test_case.when_i_clone_last_added_co_onto_record( record_name )
	##
	## clone the CO given by CO_NAME onto RWO given by RECORD_NAME
	## and cache the new cloned CO in properties[:cloned_co]

	co << _self.last_added_co()
	target << _self.rwo(record_name)

	.properties[:cloned_co] << co.clone(target)
	_self.assert_not_unset( .properties[:cloned_co], "Failed to Clone CO ", co, " onto ", target )

	>> _self 
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method design_manager_test_case.when_i_split_rwo(record_name, fname)
	##
	## Splits the geometry FNAME on RECORD_NAME through its midpoint
	##

	target << _self.rwo(record_name).perform(fname)

	(split_coord, split_theta) << target.midpoint_coord_and_theta
	
	first_coord << coordinate.new(split_coord.x - (sin(split_theta) * 10),
				      split_coord.y + (cos(split_theta) * 10))
	last_coord << coordinate.new(split_coord.x + (sin(split_theta) * 10),
				     split_coord.y - (cos(split_theta) * 10))
	
	a_sector_rope << sector_rope.new_from(sector.new_with_xy(first_coord.x, first_coord.y,
								 last_coord.x, last_coord.y))
	
	target.split_with_sectors(a_sector_rope)
	
	>> _self
	
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method design_manager_test_case.then_cloned_co_work_point_is_same_as_last_added_co_work_point()

	_self.assert_equals( .properties[:cloned_co].dw!scheme_wp,
			     .properties[:last_added_co].dw!scheme_wp,
			     "clone() on MA failed for the reason - cloned MA's work record is not same as the cloning MA's work record")

	>> _self
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_test_case.last_added_co()

	co << .properties[:last_added_co]
	_self.assert_not_unset( co, "Last added CO not found")

	>> co
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_test_case.cloned_co()

	co << .properties[:cloned_co]
	_self.assert_not_unset( co, "Cloned CO not found")

	>> co
_endmethod
$

_pragma(classify_level=restricted,topic=MUnit)
_method design_manager_test_case.then_rwo_has_cloned_co_in_current_scheme( record_name )

	co_found? << _false 
	clone_co << _self.cloned_co()
	rwo << _self.rwo(record_name)
	cos_of_pole_rwo << cost_object_library.scheme_cos_for_rwo(rwo, :active_scheme)
	
	_for co _over cos_of_pole_rwo.fast_elements()
	_loop
		_if co.id = clone_co.id
		_then
			co_found? << _true
			_leave
		_endif
	_endloop

	_self.assert_true( co_found?, "Clone() on CO failed - RWO should have the cloned CO")

	>> _self 
_endmethod
$
	


_pragma(classify_level=debug, topic={Munit})
_private _method design_manager_test_case.get_records_when_running_qm(design_source_class, _gather args)
	## 
	## This method does not really run QM.  It creates an instance
	## of the eo_qm_design_source.  The
	## then_change_detector_engine_returns_all_records_in_design()
	## will check the records on this class to ensure that all
	## expected records are included.
	##

	# swg_dsn_scheme.changes_between_views() returns the
	# differences between current_view and base_view.  The tests
	# try to use a child design and the parent design as "DM Top".
	# To simulate this, make sure that the base_view's path is just
	# one level up from the current path
	stub_method_helper.replace_method(swg_dsn_user_alternative_control, :|request_replicate_view_for_scheme()|,
					  _proc(top_scheme, dataset_name, _gather args)
						  base_view << _self.saved!request_replicate_view_for_scheme(top_scheme,
													     dataset_name,
													     _scatter args)
						  datasets     << swg_dsn_admin_engine.active_scheme_dataset_names
						  inx          << datasets.index_of(dataset_name)
						  current_view << swg_dsn_admin_engine.active_scheme_datasets[inx]
						  alt_path     << current_view.alternative_path
						  current_path << write_string("|", alt_path.join_as_strings("|"))
						  
						  base_view.go_to_alternative(current_path)
						  base_view.up()
						  
						  >> base_view
						  
					  _endproc)

	design_source << design_source_class.new(_scatter args)
	_return design_source.records
	
_endmethod
$



_pragma(classify_level=debug, topic={Munit})
_method design_manager_test_case.then_the_records_include_all_the_expected_ones(label, actual_records, expected_ids)
	##
	## ACTUAL_RECORDS are modified by this method.  All records
	## from EXPECTED_IDS found in ACTUAL_RECORDS are removed from
	## ACTUAL_RECORDS.
	##
	## When this method terminates, ACTUAL_RECORDS contains
	## additional records that were not specified in EXPECTED_IDS.
	##

	_for expected_id _over expected_ids.fast_elements()
	_loop
		expected_record << .properties[expected_id]
		fail_str << write_string("Expected detected changed records for ", label,
					 " to include ", expected_id)
		_self.assert_true(actual_records.includes?(expected_record), fail_str)

		_if actual_records.includes?(expected_record)
		_then
			actual_records.remove(expected_record)
		_endif
	_endloop
	
	>> _self
	
_endmethod
$

_pragma(classify_level=debug, topic={Munit})
_method design_manager_test_case.then_the_records_do_not_include_unexpected_ones(label, actual_records)
	## 
	## then_the_records_include_all_the_expected_ones() should be
	## called first to remove the expected records from
	## ACTUAL_RECORDS
	##
	
	fail_str << write_string("Detected changed records for ", label,
				 " unexpectedly included ",
				 _self.format_record_list(actual_records))
	
	_self.assert_true(actual_records.empty?, fail_str)

	>> _self 
	
_endmethod
$

_pragma(classify_level=debug)
_private _method design_manager_test_case.format_record_list(records)
	##
	## Format records into a comma separated list.
	##
	## If a record is one that we have stored in the properties
	## slot, show the key for the record rather than the key itself.
	##
	_local me << _self
	>> simple_vector.new_from(records).
		map(_proc(value)
			    _import me
			    >> _if (key << me.key_for_record(value)) _isnt _unset
			       _then
				       >> key
			       _else
				       >> value
			       _endif
		    _endproc).
		join_as_strings(", ")
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_test_case.key_for_record(rec)
	##
	## IF REC is stored in .properties, return its key.
	## Otherwise return _unset.
	##
	## Finding the key is slow, but this should only be called when
	## the test has failed, so shouldn't matter.
	## 
	_for key, value _over .properties.fast_keys_and_elements()
	_loop
		_if key _is :last_element _orif # Ignore the generic key
		    _not value.responds_to?(:is_valid?) _orif # Not a record
		    _not value.is_valid? # Deleted record
		_then
			_continue
		_endif
		
		_if value = rec
		_then
			_return key
		_endif
	_endloop
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_test_case.note_change( who, what, data )
	##
	## Conflict resolution method
	## Use design_manager_system_test_mixin.note_change() so that
	## serialised_test_mixin.note_change() is called.  This is needed so that events
	## are passed on; failure to do so may cause tree_items to not update correctly.
	##
	
	_super( design_manager_system_test_mixin ).note_change( who, what, data )
	
_endmethod
$
