#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug)
def_slotted_exemplar(:eo_dnom_base_case,
{
},
{:eo_gisa_base_test_case, :eo_dnom_test_mixin})
$

_pragma(classify_level=debug)
eo_dnom_base_case.define_shared_constant( :application_name,:eo_dnom_application, :public)
$

_pragma(classify_level=debug)
eo_dnom_base_case.define_shared_constant( :admin_application_name,:eo_dnom_admin_application, :public)
$

_pragma(classify_level=debug)
eo_dnom_base_case.define_shared_constant( :plugin_name, :dnom_adapter, :public )
$

_pragma(classify_level=debug)
eo_dnom_base_case.define_shared_constant( :target_coordinate_system_name, :uk_british_national_grid_m, :public )
$

_pragma(classify_level=debug)
eo_dnom_base_case.define_shared_constant( :properties_helper, sw_dnom_properties_helper, :public )
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.note_change( who, what, data )
	##
	## Conflict resolution from two times inherited
	## sw:serialised_test_mixin.
	##
	_super( eo_dnom_test_mixin ).note_change( who, what, data )
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.given_prop_values(_gather prop_values)
	##
	
	.properties[:proposed_values] << property_list.new_with(_scatter prop_values)

	_return _self
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.given_object_fill_checks(_gather p_checks)
	##
	
	l_checks << property_list.new_with(_scatter p_checks)

	_for l_key, l_filled? _over l_checks.fast_keys_and_elements()
	_loop
		exists? << .properties[:object_of_interest].perform(l_key) _isnt _unset 
		_self.assert_is(l_filled?, exists?, l_key + " value is not correct. ")
	_endloop
	
	_return _self
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.given_run_insert_transaction()
	##
	
	record_transaction.new_insert(.properties[:collection_of_interest], .properties[:proposed_values]).run()

	_return _self
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.given_run_update_transaction()
	##
	
	record_transaction.new_update(.properties[:object_of_interest], .properties[:proposed_values]).run()

	_return _self
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.given_default_config_name(name)
	##
	## Stubs sw_dnom_properties_helper.default_config_name to
	## return given NAME.
	##

	stub_method_helper.replace_method(sw_dnom_properties_helper,
					  :default_config_name,
					  _proc ()
						  _import name
						  _return name
					  _endproc)

	_return _self
_endmethod
$

_pragma(classify_level=debug,topic={MUnit, Test})
_method eo_dnom_base_case.when_object_is_deleted()
	##
	
	record_transaction.new_delete(.properties[:object_of_interest]).run()

	_return _self
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.create_request_for_as_built_current_design_locally(_optional export_type)
	## Process the circuit request, using the %TEMP% for output and
	## without messaging
	
	request << sw_dnom_substation_export_helper.create_request_to_export_differences(export_type.default(:as_built)) 

	# don't delete xml files for tests
	request.set_property( :test_mode?, _true )

	# export primary substation internals
	request.set_property( :export_station_internals?,
			      _self.properties[:export_station_internals?].default(_true) )

	# write the schematics files for tests
	request.set_property( :export_schematics?,
			      _self.properties[:export_schematics?].default(_true) )

	# Override export future network property if needed.
	_if _self.properties[:export_future_network?] _isnt _unset
	_then 
		request.set_property(:export_future_network?,
				     _self.properties[:export_future_network?])
	_endif
	
	# sw_dnom_split_export_manager now requires exchange_job_id property to be set
	request.set_property( :exchange_job_id, :dummy_exchange_job_id )
	
	# sw_dnom_message_manager now requires :ds_version_timestamp property to be set
	request.set_property( :ds_version_timestamp, :dummy_ds_version_timestamp )
	
	# set design_splitter_class_name if given in .properties slot
	_if (splitter_name << .properties[:splitter_name]) _isnt _unset 
	_then 
		request.set_property( :design_splitter_class_name, splitter_name)
	_endif 

	# Disable exchange job creation
	stub_method_helper.replace_method(sw_dnom_exchange_job_manager,
					  :|process_request()|,
					  _proc() _endproc)
	
	# Disable messaging if not requested otherwise
	_if .properties[:disable_messaging?] _isnt _false
	_then 
		stub_method_helper.replace_method(sw_dnom_message_manager,
						  :|process_request()|,
						  _proc() _endproc)
	_endif
	
	>> request 
_endmethod 
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.export_differences_from_current_design_locally(_optional export_type)
	## Process the circuit request, using the %TEMP% for output and
	## without messaging

	request << _self.create_request_for_as_built_current_design_locally(export_type)

	process_name << request.get_property(:process_name)
	process_manager << sw_process_manager_cache.get_cached_instance( sw_dnom_properties_helper.installation_type )
	export_set_process << process_manager.get_process(process_name)

	_self.when_registering_written_xml_files()					  
	
	export_set_process.execute(request)
	
	_return request
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.export_substation_locally( a_substation )
	##
	
	_local l_station_provider << sw_dnom_substation_export_helper.get_substation_provider_instance()
	_local name << l_station_provider.get_sanitized_station_name(a_substation)
	
	## Process the station request, using the %TEMP% for output and
	## without messaging
	request << sw_dnom_substation_export_helper.create_request_for_substation_export( a_substation )

	request.set_property( :job_name, name )
	request.set_property( :station_urn ,  urn_manager.get_urn_from_object( a_substation ))

	process_manager << sw_process_manager_cache.get_cached_instance( sw_dnom_properties_helper.installation_type )
	export_set_process << process_manager.get_process(:dnom_station_export_request)

	# Disable DNOM messaging
	stub_method_helper.replace_method(sw_dnom_message_manager,
					  :|process_request()|,
					  _proc() _endproc)
	export_set_process.execute(request)
	_return request
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.denergised_rwo_names
	##
	## TMP method for SWV-22995 testing
	## Returns the list of rwo names keyed by their circuit_ids.
	##
	_if (denergised_rwo_names << _self.properties[:denergised_rwo_names]) _isnt _unset
	_then
		_return denergised_rwo_names
	_endif
	denergised_rwo_names << _self.properties[:denergised_rwo_names] << equality_property_list.new()
	
	denergised_rwo_names["DNOM44_1"] << equality_set.new_with(:d44_mv_bus_10)
	denergised_rwo_names["DNOM44_2"] << equality_set.new_with(:d44_mv_bus_12, :d44_cbl_2_1, :d44_sw_2_1, :d44_cbl_2_2)
	denergised_rwo_names["DNOM44_3"] << equality_set.new_with(:d44_cbl_3_2)
	denergised_rwo_names["DNOM44_4"] << equality_set.new_with(:d44_cbl_4_5, :d44_cbl_4_6, :d44_cbl_4_7, :d44_cbl_4_8, :d44_sw_4_1, :d44_bus_4_1, :d44_lv_4_xfrmr, :d44_bus_4_2)
	denergised_rwo_names["DNOM44_5"] << equality_set.new_with(:d44_cbl_5_2, :d44_cbl_5_3, :d44_bus_5_1, :d44_lv_5_xfrmr)
	
	_return denergised_rwo_names
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.denergised_rwos(circuit)
	##
	## Temporary method SWV-22995,
	## Returns set of de-energised rwo for the given CIRCUIT (works
	## for replicas too)
	## 
	rwo_names << _self.denergised_rwo_names[circuit.circuit_id]
	_if rwo_names _is _unset
	_then
		_return {}
	_endif
	
	collections << rope.new() # collections to seek rwos
	collections_names << {:eo_connector_segment_inst, :eo_isolating_eqpt_inst, :eo_cable_segment_inst, :eo_power_xfrmr_inst, :eo_3w_power_xfrmr_inst}
	_for coll_name _over collections_names.fast_elements()
	_loop
		collections.add_last(circuit.source_view.collection(coll_name))
	_endloop	

	rwos << rwo_set.new()

	_for rwo_name _over rwo_names.fast_elements()
	_loop
		name_pred << predicate.eq(:name, rwo_name)
		found_rwos << rope.new()
		_for collection _over collections.fast_elements()
		_loop
			found_rwos.add_all_last(collection.select(name_pred))
		_endloop
		_if found_rwos.size =1
		_then
			rwos.add(found_rwos[1])
		_endif		
		_self.assert_true(found_rwos.size <=1, write_string("Multiple rwos named ", rwo_name, " found: ", _scatter found_rwos))
	_endloop
	_return rwos
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.denergised_rwo_circuits(rwo)
	##
	## TMP method for SWV-22995 testing
	## Returns sets of circuits for which the RWO should belong
	## too, if it is de-energised.
	## For rwos not listed in the denergised_rwo_names returns _unset
	##
	_if _not rwo.responds_to?(:name)
	_then
		_return _unset
	_endif	
	_for circuit_id, rwo_names _over _self.denergised_rwo_names.fast_keys_and_elements()
	_loop
		_if rwo_names.includes?(rwo.name)
		_then
			circuit << rwo.source_view.collection(:eo_circuit).select(predicate.eq(:circuit_id, circuit_id)).an_element()
			_return rwo_set.new_with(circuit)
		_endif
	_endloop	
_endmethod
$

_pragma(classify_level=debug)
_method eo_dnom_base_case.given_substation_provider_with_denergised_rwos()
	##
	## TMP method for SWV-22995 testing
	## Stubs substation provider to list de-energised rwos as
	## belonging to circuits based on the the denergised_rwo_names
	## method.
	## Extends the circuit_objects_to_export() and get_circuits() methods.
	##
	_local me << _self
	stub_method_helper.replace_method(eo_dnom_substation_provider, :|circuit_objects_to_export()|,
					  _proc@stubbed_circuit_objects_to_export(circ, rwos)
						  _import me
						  _self.perform(:|saved!circuit_objects_to_export()|, circ, rwos)
						  rwos.add_all(me.denergised_rwos(circ))
						  _return rwos
					  _endproc)
	
	stub_method_helper.replace_method(eo_dnom_substation_provider, :|get_circuits()|,
					  _proc@stubbed_get_circuits(rwo)
						  _import me
						  _if (circuits << me.denergised_rwo_circuits(rwo)) _isnt _unset
						  _then
							  _return circuits
						  _else							  
							  _return _self.saved!get_circuits(rwo)
						  _endif						  
					  _endproc)
	_return _self
_endmethod
$
