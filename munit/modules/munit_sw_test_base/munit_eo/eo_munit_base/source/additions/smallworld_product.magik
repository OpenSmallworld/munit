#% text_encoding = iso8859_1

_pragma(classify_level=restricted)
_method smallworld_product.get_test_modules( _optional for_product_names )
	##
 	## Returns a property list keyed on product name; for each
	## product name, a set of test modules will be returned.
	##
	## If no product names are provided, then all products are checked.
	##
	## Parameters: an optional vector (or set)  of product names
	## Returns   : a property list
	_local test_modules << property_list.new()

	_for a_product _over smallworld_product.products.fast_elements()
	_loop
		#
		# If the product names were provided, then make sure that this
		# is one of them.
		#
		_if for_product_names _isnt _unset _andif
		    _not for_product_names.includes?( a_product.name )
		_then
			_continue 
		_endif
		
		#
		# Setup the set for the product.
		#
		product_test_modules << set.new()

		#
		# For each product, add the test modules.
		#
		_for a_module _over a_product.defined_modules.fast_elements()
		_loop
			_if a_module.test_module?
			_then
				product_test_modules.add( a_module )
			_endif
		_endloop

		#
		# Only add the product to the property list if it has test modules.
		#
		_if _not product_test_modules.empty?
		_then
			test_modules[a_product.name] << product_test_modules			
		_endif
	_endloop
	
	>> test_modules
_endmethod
$

_pragma(classify_level=restricted)
_method smallworld_product.load_test_modules( _optional for_product_names )
	## 
	## Loads all test modules for products.
	##
	## If no product names are provided, then all products have
	## their respective test modules loaded.
	##
	## Parameters: an optional vector (or set)  of product names
	## Returns   : none
	_local test_modules << _self.get_test_modules( for_product_names )

	_for a_product_name, a_set_of_test_modules _over test_modules.fast_keys_and_elements()
	_loop
		_for a_test_module _over a_set_of_test_modules.fast_elements()
		_loop
			sw_module_manager.load_module( a_test_module.name, _unset,
						       :update_image?, _false )
		_endloop
	_endloop
_endmethod
$
