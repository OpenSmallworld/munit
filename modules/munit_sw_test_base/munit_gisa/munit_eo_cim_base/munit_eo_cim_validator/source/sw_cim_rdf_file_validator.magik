#% text_encoding = iso8859_1
##
_package sw

_pragma(classify_level=restricted)
##
## A wrapper class for the CIM Validation tool (external java command
## line tool), which can compare CIM RDF files and validate them against
## profiles.
##
## NOTE: Only the comparison has been implemented.
##
## In order to be used, the following shared variables can be configured:
##
## * alternative_jre: path where an alternative Java Runtime is located (this is
##   optional)
## * cim_validator_report_path: path where the reports will be written
##
## Use:
## fv << sw_cim_rdf_file_validator.new()
## fv.compare( filename1, filename2 )
## - returns true if both files represent the same model, false otherwise
##
## fv.compare( filename1, filename2, _true )
## - as above, but a report is generated if it fails
##
## Although a new() method is provided, the current
## implementation does not require an instance of this class to
## work, the compare() method can run on the exemplar
##
def_slotted_exemplar( :sw_cim_rdf_file_validator,
	{} )
$

_pragma(classify_level=restricted)
## Condition raised when one or both filenames are unset
condition.define_condition( :cim_validator_file_unset, :error, {}, "One or more files are unset" )
$

_pragma(classify_level=restricted)
## Condition raised when the file does not exist
condition.define_condition( :cim_validator_file_not_found, :error, { :filename }, "File #1 does not exist" )
$

_pragma(classify_level=restricted)
sw_cim_rdf_file_validator.define_shared_variable( :alternative_jre,
	## By default, the environment variable JAVA_HOME is used to
	## start the external validator. If another JRE is required,
	## this should be set to that location (include the java.exe
	## in this path)
	## E.g. "\\cbgdem01\eo\CIMValidator\jre6\bin\java",
	_unset,
	:public )
$

_pragma(classify_level=restricted)
sw_cim_rdf_file_validator.define_shared_variable( :cim_validator_report_path,
	## Path where the reports will be stored by default
	## e.g. \\cbgdem01\eo\CIMValidator\reports	
	_unset,
	:public )
$


_pragma(classify_level=restricted)
sw_cim_rdf_file_validator.define_shared_variable( :cim_validator_executable,
	## Name of the CIM validator java program
	##
	"CIMValidator_CommandLine.jar",
	:private )
$

_pragma(classify_level=restricted)
sw_cim_rdf_file_validator.define_shared_constant( :commands,
	## Arguments (commands) the CIM Validator tool accepts
	property_list.new_with(
		:comparison, "-d -n",    # Compare two files
		:validation, "-c -n",    # Validate a file against a profile
		:report_directory, "-t", # Specify the directory where reports will be generated
		:generate_report, "-r",  # Generate a report
		:automated_mode, "-a",   # Generate a report only if the validation/comparison fails
		:file, "-f",             # Specify the filename 
		:profile, "-p",          # Specify the profile
		:inspector, "-i"         # Add an inspector
		      ),
	:private )
$

_pragma(classify_level=restricted)
## Inspectors included in the validation
sw_cim_rdf_file_validator.define_shared_variable( :validation_inspectors,
	{ :|allTyped|, :cardinality, :class, :|consistentType|,
	  :literal, :owl, :prefix, :property, :uri, :vocabulary },
	:public )
$

_pragma(classify_level=restricted)
sw_cim_rdf_file_validator.define_shared_constant( :return_codes,
	## Return codes that the CIM Validator tool can generate 
	property_list.new_with(
		:fail, 2,                # The comparison/validation has failed (different files or file not compliant
		                         # with the profile 
		:pass, 3                 # The comparison/validation has passed
		      ),
	:private )
$

_pragma(classify_level=restricted)
_method sw_cim_rdf_file_validator.new ()
	## Create a new instance
	##

	>> _clone.init()
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.init ()
	##
	##

	>> _self
_endmethod
$

_pragma(classify_level=restricted)
_method sw_cim_rdf_file_validator.compare ( filename1, filename2, _optional write_report?, report_path )
	## Compares the contents of FILENAME1 and FILENAME2 (two CIM file names) and
	## returns true if they are the same, false otherwise. It raises a
	## condition if the files don't exist or are unset
	## If WRITE_REPORT? is true (default value), and the files are different,
	## a report with the differences will be generated. The report
	## will be written in REPORT_PATH (or the value of the
	## shared variable cim_validator_report_path if unset)
	
	_self.ensure( filename1 )
	_self.ensure( filename2 )
	_return _self.build_and_run_command( _self.build_comparison_command( filename1, filename2 ),
					     write_report?.default( _true ), report_path )
_endmethod
$

_pragma(classify_level=restricted)
_method sw_cim_rdf_file_validator.validate ( filename, profile, _optional write_report?, report_path )
	## Validates that FILENAME (a CIM file name) is compliant with
	## the profile indicated by PROFILE (an owl file name). Returns true
	## if so, false otherwise.
	## If WRITE_REPORT? is true (false by default), and the file is not compliant,
	## a report with the differences will be generated. The report
	## will be written in REPORT_PATH (or the value of the
	## shared variable cim_validator_report_path if unset)

	_self.ensure( filename )
	_self.ensure( profile )
	_return _self.build_and_run_command( _self.build_validation_command( filename, profile ),
					     write_report?, report_path )
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.build_comparison_command ( filename1, filename2 )
	## Create the parameters required to compare FILENAME1 and FILENAME2
	##

	_return write_string( _self.commands[:comparison], space_char,
			      _self.commands[:file], space_char, %", filename1, %", space_char,
			      _self.commands[:file], space_char, %", filename2, %" )
			      
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.build_validation_command ( filename, profile )
	## Return a string with the arguments required to perform a validation of
	## FILENAME against PROFILE
	##

	_return write_string( _self.build_inspectors_list(), space_char,
			      _self.commands[:validation], space_char,
			      _self.commands[:profile], space_char, %", profile, %", space_char,
			      _self.commands[:file], space_char, %", filename, %" )
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.build_inspectors_list ()
	## Return a string containing the parameters required to add the inspectors defined in
	## the shared variable validation_inspectors
	##

	_local inspectors << rope.new()
	_for inspector _over _self.validation_inspectors.fast_elements()
	_loop
		inspectors.add( write_string( _self.commands[:inspector], space_char, inspector ) )
	_endloop
	
	_return write_string_with_separator( inspectors, space_char )
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.build_and_run_command ( command_type, write_report?, report_path )
	## Build a command around COMMAND_TYPE (a string), which represents an operation such as
	## a comparison or validation
	## Returns true if passed, false otherwise
	## Raise a condition if the files are unset or don't exist
	_local command << _self.build_command( command_type, write_report?, report_path )
	_local result << _self.run_command( command )
	_return result = _self.return_codes[:pass]
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.ensure ( filename )
	## Raise a condition if FILENAME is unset or doesn't exist.
	## Otherwise, do nothing.
	## The conditions are:
	## * cim_validator_file_unset: if file is unset
	## * cim_validator_file_not_found: if the file is not found
	
	_if filename _is _unset
	_then
		condition.raise( :cim_validator_file_unset )
	_endif

	_if _not system.file_exists?( filename )
	_then
		condition.raise( :cim_validator_file_not_found, :filename, filename )
	_endif
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.build_command ( command_type,
								      _optional write_report?, report_path )
	## Build a command to perform the operation defined in COMMAND_TYPE (a string)
	## If WRITE_REPORT? is true, the option to write a report in REPORT_PATH is
	## included. If REPORT_PATH is unset, the value of the shared
	## variable cim_validator_report_path is used.
	## Return a rope with the parts of the command
	##

	_local command << rope.new()

	command.add( _self.java_executable() )
	command.add( _self.validator_executable() )
	command.add( _self.commands[:automated_mode] )
	
	command.add( command_type )

	_if write_report? _is _true
	_then
		command.add( _self.report_command( report_path ) )
	_endif
	
	_return command
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.java_executable ()
	## Return the command to start the Java executable.
	##
	## If the alternative jre is set in the shared variable alternative_jre,
	## that will be used. If unset and JAVA_HOME is set as an environment variable
	## then "${JAVA_HOME}/bin/java" is returned.
	## Otherwise, it will return just "java"

	
	_local java_exec << "java"

	_if _self.alternative_jre _isnt _unset
	_then
		java_exec << _self.alternative_jre
	_elif (java_home << system.getenv("JAVA_HOME")) _isnt _unset 
	_then
		java_exec << system.pathname_down( java_home, "bin", "java")
	_endif
	
	_return java_exec    
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.validator_executable ()
	## Return the name of the executable ready for the external invocation
	## of the validation tool
	##

	_return "-jar " + system.pathname_from_components( _self.cim_validator_executable,
							   _self.cim_validator_path )
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.report_command ( report_path )
	## Return the parameter to write out a report in REPORT_PATH if
	## it fails. If it is unset, use the path specified in
	## cim_validator_report_path shared variable
	##

    _return write_string( _self.commands[:generate_report], space_char,
			  _self.commands[:report_directory], space_char,
			  %", report_path.default( _self.cim_validator_report_path ), %" )
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.run_command ( command )
	## Run COMMAND (which is a rope of elements that are part of the
	## command string) and return the exit code
	## Print output and error pipes with a prefix "CIMvalidation"
	## in order to direct someone looking for a cause of an error
	## into tihs method, e.g. 'CIM model1 and model2 are NULL' has
	## been written out from the command error stream, when the
	## CIMvalidator has returned with a code success (the given error
	## is produced on produced on empty files).
	## 
	_local res, code
	_local command_str << write_string_with_separator( command, %space )
	(pid, in, out, err) << system.start_command_with_io(command_str, _false, _true, _true)

	_while (line << out.get_line()) _isnt _unset
	_loop
		!output!.write("CIMvalidationOutput: ", line)
		!output!.newline()
	_endloop
	out.close()
	_while (line << err.get_line()) _isnt _unset
	_loop
		!output!.write("CIMvalidationError: ", line)
		!output!.newline()
	_endloop
	err.close()
	
	(res, code) << system.status(pid)
	>> code
_endmethod
$

_pragma(classify_level=restricted)
_private _method sw_cim_rdf_file_validator.cim_validator_path
	## Path where the CIM validator java program (cim_validator_executable)
	## can be found (in etc/x86 within the product) 

	_return system.canonicalise( "etc/x86",
				     smallworld_product.products[:sw_cim_test_utils].directory )
_endmethod
$
