#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug)
##
## This mixin defines given/when/then methods on applications.
##
## All classes that inherits from this mixin must define a
## .properties method that returns a property_list.
##
def_mixin( :application_system_test_mixin, { :serialised_test_mixin, :gui_framework_test_mixin } )
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_application( application_name )
	## 
	## Ensure that the required application (as specified by
	## APPLICATION_NAME) is running.
	##
	##     * If it is already running, the test will run
	##     * If it is available but not yet running, it will be
	##       started and the test will run 
	##     * If it is not available, the test will fail.
	##

	# Make sure there is a queue for events
	_if _self.properties[ :queue ] _is _unset
	_then
		_self.properties[ :queue ] << atomic_queue.new( 1019 )
	_endif
	
	# Make sure the application is running
	_if ( app << smallworld_product.application( application_name ) ) _is _unset
	_then
		_if ( app_def << smallworld_product.application_definition( application_name ) ) _isnt _unset
		_then
			write( "*** Starting application: ", application_name )
			# Application exists but is not yet running, start it
			app << app_def.int!start()
			_self.wait_for_application_to_be_active( application_name )
		_else
			# Application does not exist
			condition.raise( :error, :string, "Cannot find " + application_name + " application" )
		_endif
	_endif

	_if app.top_frame _isnt _unset
	_then 
		app.top_frame.maximized? << _self.properties[:frame_maximised?].default(_false)
		app.top_frame.top_canvas_container.add_dependent(_self)
	_endif 
	app.add_dependent(_self)
  
	_self.properties[ :application ] << app

	>> _self 
	
_endmethod
$


_private _method application_system_test_mixin.given_a_case_application( app_name, soc_name )
	## Start Case application with soc name (as specificied by the app_name and soc_name)
	## This would start the application in the given soc_name,
	## skipping the SOC selector dialog. 				

	app_def << smallworld_product.application_definition(app_name)
	new_app_def << application_definition.new(app_def.application_name, app_def.application_class_name, :soc_name, soc_name, _scatter app_def.properties.for_scatter())
	new_app_def.int!start()

	app << new_app_def.application
	
	app.top_frame.maximized? << true
  
	_self.properties[ :application ] << app
	
	_self.wait_for_application_to_be_active(app_name)
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_embbeded_editor( dataset_name, collection_name )
	## 
	##

	collection << _self.dataset( dataset_name ).collections[ collection_name ]
	editor << _self.editor_manager.display_embedded_editor_for_collection( collection )
	_self.properties[ :editor ] << editor

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_embbeded_editor_with_default_values( dataset_name, collection_name )
	## 
	##

	_self.given_an_embbeded_editor( dataset_name, collection_name ).
		 when_clicking_set_defaults_button()
	
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_proposed_editor_values( proposed_values )
	## 
	##

	_self.properties[ :editor ].set_proposed_values( proposed_values )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_a_trail_coordinate( x, y )
	## 
	##

	_self.map_manager.current_map.trail.add_coordinate( coordinate.new( x, y ))

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_empty_trail()
	## 
	##

	_self.map_manager.current_map.trail.empty()

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_alternative(alt_name,_optional dataset)
	##
	## given_an_alternative() for Core based applications
	## alt_name that is the name of the alternative should be
	## provided by the user in a string e.g. "test_alternative".
	## Tester can optionally provide the dataset name as a symbol
	## e.g. :gis.
	##
	## By default, given_an_alternative will always
	## create alternatives in GIS dataset.
	##
	## Example of method usage would be: given_an_alternative("test", :gis)
	## to create an alternative named test in gis dataset.

	gpm << gis_program_manager
	_if dataset _is _unset
	_then
		ds << gpm.databases[:gis]
	_else
		ds << gpm.databases[dataset]
	_endif

	ds.goto_top_alternative()

	_if ds.has_alternative?(alt_name) _is _false
	_then
		ds.create_alternative(alt_name)
	_endif

	ds.go_to_alternative(alt_name)
	ds.switch(:write)

	>> _self 
	
_endmethod 
$


_pragma(classify_level=debug)
_method application_system_test_mixin.get_item( id_path )
	## 
	## Return the UI widget matching the supplied string ID_PATH.

	>> sw_swift_manager.get_item_with_path( id_path )
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.get_item_with_identifier(tag, identifier, _gather keys_and_values)
	## 
	## Return the item of type TAG with identifier IDENTIFIER.
	## Look on the top_canvas_container of
	## .properties[:application], except if the :frame_title key is supplied.
	##
	## KEYS_AND_VALUES are additional optional properties. Valid properties are:
	##
	## :frame_title - the title of an active frame in which to search for the item
	## to return.
	##
	## This method can return unset
	##
	
	props << property_list.new_from_gathered(keys_and_values)
	container << _self.container_for_frame(props[:frame_title])
	props.remove_key(:frame_title)
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		_if item.identifier = identifier
		_then
			found_item << item
			_leave
		_endif
	_endloop

	>> found_item
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_inserting_record()
	## 
	##

	_dynamic !current_application!
	!current_application! << _self.properties[ :application ]

	action << _self.insert_action()
	_self.click_action_button( action )

	_self.properties[:new_record] << _self.properties[ :editor ].current_object
	
	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item( id_path, _optional new_frame_wait_time )
	##
	## Note: Where possible please use when_clicking_item_with_identifier() instead.
	## That method finds GUI items in a more robust manner. That method also
	## provides support for clicking items which invoke message dialogs. Using this
	## method to invoke a message dialog may block the test thread and require manual
	## intervention for the test to continue.
	##
	## Click on the Swift widget identified by the path string ID_PATH.
	##
	## ID_PATH can be found using get_identifier_path() and is
	## displayed in the Object Spy for widgets with a unique
	## identifier path.
	##
	## (Load magik_tools from sw_dev_tools to enable Swift Explorer
	## and activate it using F4 key)

	click_item << _self.get_item( id_path )
	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, property_list.new_with(:new_frame_wait_time, new_frame_wait_time) )
	_else
		write( "Clicking on [", id_path, "] failed - item not found" )
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_action( plugin_name, action_name,
							    _optional new_frame_wait_time )
	## 
	## Click on the ACTION_NAME action of the PLUGIN_NAME plugin.
	## This plugin is a plugin of .properties[ :application ]
	##

	action << _self.properties[ :application ].plugin( plugin_name ).action( action_name )
	_self.click_action_button( action, new_frame_wait_time )

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_tab( tab_name )
	## 
	## 

	container << _self.properties[ :application ].top_frame.top_canvas_container
	
	_for item _over container.get_items_of_type( :tag!sw_tab_container ).fast_elements()
	_loop @item

		_for label_item _over item.tab_container.get_items_of_type( :tag!sw_label_item ).fast_elements()
		_loop
			_if label_item.label = tab_name
			_then
				tab_label << label_item
				tab       << item
				_leave @item
			_endif
		_endloop 
		
	_endloop

	_self.properties[ :tab ] << tab
	_self.properties[ :tab_label ] << tab_label
	
	_self.click_item( tab_label )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_pulldown_menu_item_with_identifier( identifier,
											_optional new_frame_wait_time,
											frame_title )
	## Clicks the sw_pulldown_menu_item with IDENTIFIER and adds
	## its .pulldown_menu to .properties[:pulldown_menu]
	##

	_self.when_clicking_item_with_identifier( :tag!sw_pulldown_menu_item, identifier,
						  :new_frame_wait_time, new_frame_wait_time.default(250),
						  :frame_title, frame_title )
	
	_self.properties[ :pulldown_menu ] << _self.properties[ :click_item ].pulldown_menu
	
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_pulldown_menu( id_path,
									_optional new_frame_wait_time )
	## when_clicking_pulldown_menu_item assumes a tag of
	## tag!sw_pulldown_menu_item and uses an identifier. This
	## method uses an ID path. Adds the .pulldown_menu from the the
	## ID_PATH container to .properties[:pulldown_menu]
	## 

	_self.when_clicking_item( id_path, new_frame_wait_time.default(250) )

	_self.properties[ :pulldown_menu ] << _self.properties[ :click_item ].pulldown_menu

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_with_label( tag, label,
								     _optional container, new_frame_wait_time )
	## 
	##	

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		_if item.responds_to?( :label ) _andif
		    item.label = label
		_then
			click_item << item
			_leave
		_endif
	_endloop

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, property_list.new_with(:new_frame_wait_time, new_frame_wait_time) )
	_else
		condition.raise(:error, :string, write_string("Failed to find component with label ", label))
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_containing_label( tag, label,
									   _optional container, new_frame_wait_time )
	## 
	##	

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif

	click_item << _unset
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		label_item << item.get_items_with_text( label ).an_element()
		_if label_item _isnt _unset
		_then
			click_item << item
			_leave
		_endif
	_endloop

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, property_list.new_with(:new_frame_wait_time, new_frame_wait_time) )
	_else
		condition.raise( :error, :string,
				 write_string("Failed to find component with label ", label) )
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_with_identifier( tag, identifier,
									  _gather keys_and_values)
	## 
	## Click on the item of type TAG and with IDENTIFIER.
	## The item is found on .properties[:application]'s top frame, unless the
	## :frame_title is specified, in which case the item is found on the active
	## frame with the specified title.
	##
	## KEYS_AND_VALUES are additional optional properties. Valid properties are:
	##
	## :new_frame_wait_time - if the click will activate a new frame, this specifies
	## the time to wait for the new frame to activate.
	##
	## :frame_title - the title of an active frame in which to search for the item
	## to click
	##
	## :message_dialog_wait_id - this must be specified if clicking on the item will invoke a
	## message dialog. It ensures that activating the dialog will not block the test
	## thread. The value should be a symbol. It should be passed to
	## when_waiting_for_message_dialog_invocation_to_complete() after the test closes
	## the dialog so the test will wait for the frame to deactivate.
	##
	
	props << property_list.new_from_gathered(keys_and_values)
	click_item << _self.get_item_with_identifier(tag, identifier, _scatter keys_and_values)

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, props )
	_else
		condition.raise( :error, :string,
				 write_string("Failed to find component with identifier ", identifier) )
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_in_canvas( id_path, x, y, _optional id )
	## 
	## 

	a_canvas << _unset
	top_con << _self.properties[ :application ].top_frame.top_canvas_container
	
	_for c _over top_con.all_canvases()
	_loop
		_if c.responds_to?( :get_identifier_path|()| ) _andif
		    c.get_identifier_path() = id_path
		_then
			a_canvas << c
			_leave
		_endif
	_endloop
	
	_if id _is _unset
	_then
		id << :left
	_endif
	
	_self.handle_event( a_canvas, :button, id, x, y, :press, 0 )
	_self.handle_event( a_canvas, :button, id, x, y, :release, 0 )

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_expanding_tree_element( tree_id_or_path, a_string,
								   _optional parent_string, expand? )
	## 
	## Expands the element displaying a string matching A_STRING.
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.

	dt << _self.get_display_tree( tree_id_or_path, a_string, parent_string )
	_if dt _isnt _unset
	_then
		dt.expanded? << expand?.default(_true)
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_expanding_all_tree_elements( tree_id_or_path )
	## 
	## Expands all elements in the tree_item.
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	
	a_tree_item << _self.get_tree_item( tree_id_or_path )
	_if a_tree_item _is _unset
	_then
		_return _self
	_endif

	_for dt _over a_tree_item.tree_manager.fast_visible_trees()
	_loop
		dt.expand_fully()
	_endloop
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_selecting_tree_element( tree_id_or_path, a_string,
								   _optional parent_string, modmask )
	## 
	## Selects the element displaying a string matching A_STRING.
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.

	selected_dt << _self.get_display_tree( tree_id_or_path, a_string, parent_string )
	_if selected_dt _isnt _unset
	_then
		a_tree_item << _self.get_tree_item( tree_id_or_path )
		index << 1
		_for dt _over a_tree_item.tree_manager.fast_visible_trees()
		_loop
			_if dt _is selected_dt
			_then
				renderer << a_tree_item.tree_renderer
				x << renderer.headings_holder.row_headings_width + 10
				_if _not renderer.style_holder.tabular_style?
				_then
					# Indent for each level down in the tree
					current_dt  << dt
					box_spacing << renderer.style_holder.box_spacing
					_loop
						_if ( current_dt << current_dt.parent ) _is _unset
						_then
							_leave
						_endif
						x +<< box_spacing
					_endloop
				_endif
				y << a_tree_item.int!ypos_for( index ) + renderer.half_row_height
				
				_self.handle_event(a_tree_item, :button, :left, x, y, :press, modmask.default(0))
				_self.handle_event(a_tree_item, :button, :left, x, y, :release, modmask.default(0))
				
				_leave
			_endif
			index +<< 1
		_endloop
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_tree_contains_element( tree_id_or_path, a_string,
								  _optional parent_string, selected? )
	## 
	## Asserts a tree_item contains an element displaying a string matching A_STRING.
	## Optionally asserts the string displayed in the parent element.
	## If SELECTED? is true assert that the element IS selected.
	## If SELECTED? is false assert that the element IS NOT selected.
	## If SELECTED? is not provided don't care whether it is selected.
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.

	a_tree << _self.get_display_tree( tree_id_or_path, a_string, parent_string )

	_if selected? _is _true 
	_then
		fail_str << write_string( "Tree element ", tree_id_or_path, " should be selected but isn't" )
		_self.assert_true( a_tree.selected?, fail_str )
	_elif selected? _is _false
	_then
		fail_str << write_string( "Tree element ", tree_id_or_path, " should not be selected but is" )
		_self.assert_false( a_tree.selected?, fail_str )
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=restricted)
_method application_system_test_mixin.then_tree_contains_elements( tree_id_or_path, strings )
	## 
	## Asserts a tree_item contains a hierarchy of strings
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	##
	## For example:
	## then_tree_contains( :am_tree, { "Grandparent", "Parent", "Child" } )
	## will check that the tree looks like
	## Grandparent
	## - Parent
	##   - Child
	##

	_for i _over 1.upto( strings.size - 1 )
	_loop
		_self.then_tree_contains_element( tree_id_or_path, strings[i+1], strings[i] )
	_endloop 

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_number_of_rows_in_tree_is( tree_id_or_path, expected_rows )
	## 
	## Asserts the number of visible rows in a tree item is EXPECTED_ROWS
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	
	a_tree_item << _self.get_tree_item( tree_id_or_path )
	_if a_tree_item _is _unset
	_then
		_return _self
	_endif

	visible_trees  << 0
	_for dt _over a_tree_item.tree_manager.fast_visible_trees()
	_loop
		visible_trees +<< 1
	_endloop
	
	_self.assert_equals( expected_rows, visible_trees,
			     write_string( "Expected tree '", tree_id_or_path,
					   "' to have ", expected_rows, " rows. #1" ) )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_number_of_selected_rows_in_tree_is( tree_id_or_path, expected_selected )
	## 
	## Asserts the number of selected rows in a tree item is EXPECTED_SELECTED
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	
	a_tree_item << _self.get_tree_item( tree_id_or_path )
	_if a_tree_item _is _unset
	_then
		_return _self
	_endif

	selected_trees << 0
	_for dt _over a_tree_item.tree_manager.fast_visible_trees()
	_loop
		_if dt.selected?
		_then
			selected_trees +<< 1
		_endif 
	_endloop
	
	_self.assert_equals( expected_selected, selected_trees,
			     write_string( "Expected tree '", tree_id_or_path,
					   "' to have ", expected_selected, " rows selected. #1" ) )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_number_of_trees_matching( tree_id_or_path, a_string, expected )
	## 
	## Asserts the number of rows in a tree item that match A_STRING is EXPECTED
	## 
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	
	a_tree_item << _self.get_tree_item( tree_id_or_path )
	_if a_tree_item _is _unset
	_then
		_return
	_endif
	
	matches << _self.get_display_trees( a_tree_item, a_string )
	fail_str << write_string( "Wrong number of instances of ", a_string, " - #1" )
	_self.assert_equals( expected, matches.size, fail_str )

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.get_tree_item( tree_id_or_path )
	## 
	## Returns a tree_item with the specified id or identifier path. 

	a_tree_item << _unset
	
	a_container << _self.get_item( tree_id_or_path )

	_if a_container.responds_to?( :|tag!tree_item| )
	_then
		a_tree_item << a_container
		
	_elif a_container.responds_to?( :|tag!sw_container_base| )
	_then
		_for c _over a_container.all_canvases()
		_loop
			_if c.responds_to?( :|tag!tree_item| )
			_then
				_if a_tree_item _isnt _unset
				_then
					a_tree_item << _unset
					_leave
				_endif
				a_tree_item << c
			_endif
		_endloop
	_endif

	_if a_tree_item _is _unset
	_then
		_for cc _over sw_swift_manager.active_top_containers().fast_elements()
		_loop @outer
			_for c _over cc.all_canvases()
			_loop
				_if c.responds_to?( :|tag!tree_item| ) _andif
				    c.id = tree_id_or_path
				_then
					a_tree_item << c
					_leave @outer
				_endif
			_endloop
		_endloop
	_endif
	
	fail_str << write_string( "Expected to find tree_item '", tree_id_or_path, "'" )
	_self.assert_not_unset( a_tree_item, fail_str )

	>> a_tree_item
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.get_display_trees( a_tree_item, a_string )
	## 
	## Returns all display_trees showing a string matching A_STRING.

	matches << rope.new()

	_for dt _over a_tree_item.tree_manager.fast_visible_trees()
	_loop
		_if dt.as_charvec().matches?( a_string )
		_then
			matches.add_last( dt )
		_endif
	_endloop
	
	>> matches
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.get_display_tree( tree_id_or_path, a_string,
								 _optional parent_string )
	## 
	## Returns a display_tree showing a string matching A_STRING
	## and optionally with a parent showing a string matching PARENT_STRING.

	a_tree_item << _self.get_tree_item( tree_id_or_path )
	_if a_tree_item _is _unset
	_then
		_return
	_endif
	
	matches << _self.get_display_trees( a_tree_item, a_string )
	
	result << matches.an_element()
	fail_str << write_string( "Expected to find display_tree matching '", a_string, "'" )

	_if _not matches.empty? _andif
	    parent_string _isnt _unset
	_then
		result << _unset
		_for dt _over matches.fast_elements()
		_loop
			parent_dt << dt.parent
			_if parent_dt.as_charvec().matches?( parent_string )
			_then
				result << dt
				_leave
			_endif
		_endloop
		fail_str << write_string( "Expected parent display tree matching '", parent_string, "'" )
	_endif

	_self.assert_not_unset( result, fail_str )

	>> result
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_going_to_bounds( xmin, ymin, xmax, ymax )
	## 
	##

	bounds << bounding_box.new( xmin, ymin, xmax, ymax )
	_self.map_manager.goto( bounds )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_refreshing_the_map()
	## 
	## Refresh the map and wait for the rendering to complete
	##

	# Add self as a dependent on the render_controller to be able
	# to wait for :end_render
	
	current_map << _self.map_manager.current_map
	n_views << 0
	_for view _over current_map.views()
	_loop
		n_views +<< 1
		view.sys!slot( :controller ).add_dependent( _self )
	_endloop

	_self.when_clicking_item( "application|map_gui_framework.view_refresh" )

	# Wait for each view to finish rendering.  Wait for a maximum
	# of 1 second per view
	_self.remove_value_from_queue( :end_render )
	_for view_index _over range( 1, n_views )
	_loop
		_self.wait_for_value_on_queue( :end_render, _unset, 1000 )
	_endloop

	# Remove the dependencies
	_for view _over current_map.views()
	_loop
		n_views +<< 1
		view.sys!slot( :controller ).remove_dependent( _self )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_set_defaults_button()
	## 
	## 

	action << _self.properties[ :editor ].component( :field_lister ).action( :set_defaults )

	_self.click_action_button( action )

	>> _self

_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_setting_value_in_text_item( id_path, new_text )
       ## 
       ## Set up Swift widget's VALUE to the NEW_TEXT.
       ## This method can be used to set values in the text fields.
       ## Text field should be ENABLED.
       ##
       ## ID_PATH can be found using get_identifier_path() and is
       ## displayed in the Swift Explorer for widgets with a unique
       ## identifier path.
       ##
       ## NEW_TEXT is string value provided to the Swift widget, 
       ## the widget should be enabled.
       
       item << _self.get_item( id_path )

       # set the NEW_TEXT when ITEM is enabled.       
       _if item.enabled? _is _true
       _then 
              item.value << new_text
       _else
              condition.raise( :error, :string, write_string( "Unable to set the text because the item ", item, " is not enabled." ))
       _endif

       >> _self
       
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_setting_value_in_text_item_with_identifier( identifier, new_text, _optional frame_title )
	## 
	## Set up Swift widget's VALUE to the NEW_TEXT.
	## This method can be used to set values in the text fields.
	## Text field should be ENABLED.
	##
	## IDENTIFIER is the identifier of the widget to set the value for.
	##
	## NEW_TEXT is string value provided to the Swift widget, 
	## the widget should be enabled.
	##
	## FRAME_TITLE if supplied is the title of the frame on which
	## to look for the widget.
	##
	
	item << _self.get_item_with_identifier(:tag!sw_text_item, identifier, :frame_title, frame_title)

	_if item _isnt _unset
	_then 
		# set the NEW_TEXT when ITEM is enabled.       
		_if item.enabled? _is _true
		_then	
			item.value << new_text
		_else
			condition.raise( :error, :string, write_string( "Unable to set the text because the item ", item, " is not enabled." ))
		_endif
	_else
		condition.raise( :error, :string,
				 write_string("Failed to find component with identifier ", identifier ))
	_endif
	
	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_populating_editor_by_getting_record( dataset_name, collection_name, properties,
							    _optional id_path )
	## 
	## Get the record(s) based on PROPERTIES.
	## In the Absence of selecting objects from the map, the
	## alternative is to Get the Record in the Editor and Click
	## Select Geometry button.
	## Provide the search critieria as 'Properties'
	##
	## ID_PATH is ID_Path for the Get button. If it is not supplied
	## the button with identifier :get will be clicked.
	##
	## Example: when_populating_editor_by_getting_record(:electric,  :sub_substation,
	##                              property_list.new_with(:asset_id, "sanity_substation"))
	##                                
	##
	
	_self.given_an_embbeded_editor( dataset_name,  collection_name ).
		given_proposed_editor_values( properties )
	_self.remove_value_from_queue( :task_complete )
	_if id_path _isnt _unset
	_then			   
		 _self.when_clicking_item( id_path )	
	_else			  		  
		
	 	 _self.when_clicking_item_with_identifier(:tag!sw_button_item, :get)
	_endif	

	# Getting records happen in a separate thread. Wait for the
	# task to complete. 
	
	_self.wait_for_task_to_complete( :|int!object_editor_get()| )
	
	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_selecting_objects_in_the_map( rwos )
	## 
	## Set the current map selection to RWOS
	##

	geoms << geometry_set.new()
	_for rwo _over rwos.fast_elements()
	_loop
		_for geom _over rwo.all_geometry()
		_loop
			geoms.add( geom )
		_endloop
	_endloop

	_self.properties[ :application ].databus.make_data_available( :set_map_selection, { _unset, geoms })

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_going_to_inserted_record()
	## 
	## In the current map view, go to the primary spatial context
	## of the record stored in .properties[:new_record]
	##
	## Raise a condition if:
	## - There is no record in .properties[ :new_record ]
	## - The record does not have a primary spatial context name 
	##

	_if ( record << _self.properties[ :new_record ]) _isnt _unset
	_then
		manager << _self.map_manager
		mv << manager.current_map_view
		app << _self.properties[ :application ]
		
		_if ( sc_name << app.get_primary_spatial_context_name_for( record )) _isnt _unset
		_then 
			sc << app.get_spatial_context_for( record, sc_name )
			mv.goto( sc )
		_else
			condition.raise( :user_error, :string, "No primary spatial context for " + record )
		_endif
	_else
		condition.raise( :user_error, :string, "No record to go to" )
	_endif

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_record_inserted( dataset_name, collection_name, field_name, value )
	## 
	## Find the record in the collection named COLLECTION_NAME with
	## VALUE for the field named FIELD_NAME in the difference
	## stream between the current view and the base view.
	##

	ds_view    << _self.dataset( dataset_name )
	collection << ds_view.collections[ collection_name ]
	
	base_view << ds_view.replicate( :base )
	found?    << _false 

	_protect 

		stream << ds_difference_stream.new_on( collection, base_view.collections[ collection_name ] )

		_loop
			
			( change, record, base_record ) << stream.get()
			_if record _is _unset _then _leave _endif

			_if base_record _is _unset _andif
			    record.perform( field_name ) = value
			_then
				found? << _true
			_endif
			
		_endloop

	_protection
		base_view.discard()
	_endprotect

	fail_str << write_string( "Expected record in ", collection_name, " with field ", field_name, " = ", value, " not found" )
	_self.assert_true( found?, fail_str )

	>> _self 
		
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_masthead_title_is( expected_title )
	## 
	##

	title << _self.properties[ :application ].menubar.masthead_title

	fail_str << write_string( "The expected masthead title is ", newline_char, expected_title, newline_char )
	fail_str << write_string( fail_str, "but it is", newline_char, title )

	_self.assert_equals( expected_title, title, fail_str )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_dataset_light_is( expected_colour )
	## 
	## EXPECTED_COLOUR is a symbol, either, :red, :orange or :green
	##

	top_container << _self.properties[ :application ].top_frame.top_canvas_container
	
	write_item << top_container.get_item( :db_access_write )
	read_item  << top_container.get_item( :db_access_read  )
	mixed_item << top_container.get_item( :db_access_mixed )

	_if expected_colour _is :red
	_then
		grey_items << property_list.new_with( :green, write_item, :orange, mixed_item )
		red_light  << smallworld_product.get_raster_image( :traffic_light_red, :ui_resources )

		fail_str << "The red light isn't red"
		_self.assert_equals( read_item.image, red_light, fail_str )
		
	_elif expected_colour _is :green
	_then
		grey_items  << property_list.new_with( :red, read_item, :orange, mixed_item )
		green_light << smallworld_product.get_raster_image( :traffic_light_green, :ui_resources )

		fail_str << "The green light isn't green"
		_self.assert_equals( write_item.image, green_light, fail_str )
		
	_else
		grey_items   << property_list.new_with( :green, write_item, :red, read_item )
		orange_light << smallworld_product.get_raster_image( :traffic_light_yellow, :ui_resources )

		fail_str << "The orange light isn't orange"
		_self.assert_equals( mixed_item.image, orange_light, fail_str )
		
	_endif

        grey_light << smallworld_product.get_raster_image( :traffic_light_grey, :ui_resources )
	_for light_name, grey_item _over grey_items.fast_keys_and_elements()
	_loop
		fail_str << write_string( "The ", light_name, " light should be grey, but it isn't" )
		_self.assert_equals( grey_item.image, grey_light, fail_str )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_label_is( expected_string )
	## 
	## 

	editor << _self.properties[ :editor ]
	con << editor.sys!slot(:container)

	collection_string << _if ( a_label_item << con.get_item("collection_name_label") ) _isnt _unset
			     _then
				     >> a_label_item.label
			     _endif
	
	status_string << _if ( a_label_item << con.get_item("status_label") ) _isnt _unset
			 _then
				 >> a_label_item.label
			 _endif
	actual_string << write_string( collection_string, " ", status_string )
	
	_self.assert_equals( expected_string, actual_string )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_field_displays( field_name, expected_string )
	## 
	## 

	# FIXME - should check what is displayed in editor tree_item
	
	editor << _self.properties[ :editor ]
	field_editor << editor.component( :field_lister ).field_editor( field_name )
	
	actual_string << _if ( actual << field_editor.field_item.value ) _isnt _unset
			 _then
				 >> actual.write_string
			 _endif

	fail_str << write_string( "Expected field " + field_name, " to have value '", expected_string,
				  "' not '", actual_string.default(""), "'" )
	_self.assert_equals( expected_string, actual_string, fail_str )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_fields_display( expected_values )
	## 
	## EXPECTED_VALUES is a property list keyed on field name
	##

	_for field_name, expected_value _over expected_values.fast_keys_and_elements()
	_loop
		_self.then_editor_field_displays( field_name, expected_value )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.get_map_geoms()
	## 
	## 

	manager << _self.map_manager
	mv << manager.current_map_view
	>> mv.get_visible_geometry_set()
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_record_is_shown_on_map( rwo )
	## 
	## Verify that the record inserted is available on the main map.

	geoms << _self.get_map_geoms()
	
	_self.assert_true( geoms.rwo_set().includes?( rwo ),
			   "Expect current map to show " + rwo.description() )

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_map_contains( rwo_collection_name, expected_number ) 
	## 
	## Asserts the map contains the correct number of rwos from the
	## specified collection.

	geoms << _self.get_map_geoms()
	
	actual_number << 0
	_for a_rwo _over geoms.rwo_set().fast_elements()
	_loop
		col << a_rwo.source_collection
		_if col.name = rwo_collection_name _orif
		    col.external_name = rwo_collection_name
		_then
			actual_number +<< 1
		_endif
	_endloop

	fail_str << write_string( "Expected ", expected_number,
				  " from collection ", rwo_collection_name, ". #1" )
	_self.assert_equals( expected_number, actual_number, fail_str )

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_dialog_activated( plugin_name, dialog_name )
	## 
	## Verify whether a dialog is active/available on the screen.
	
	a_plugin << _self.properties[ :application ].plugin( plugin_name )
	_if a_plugin _isnt _unset
	_then
		a_dialog << a_plugin.dialogs[ dialog_name ]
	_endif

	_self.add_dialog( a_dialog )
	
	fail_string << write_string( "Dialog: ", dialog_name, " Not found from Plugin: ", plugin_name )
	_self.assert_not_unset( a_dialog, fail_string )

	>> _self  

_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_item_enabled?( id_path, expected_state, _optional frame_title )
	## 
	## Verify the state of a Swift widget, identified by the 
	## path string ID_PATH, is Enabled or Disabled.
	## 
	## ID_PATH can be found using get_identifier_path() and is
	## displayed in the Object Spy for widgets with a unique
	## identifier path.
	##
	## EXPECTED_STATE is enabled? attribute of the Swift widget 
	## which could either _true(Enable) or _false(Disable)

	container << _self.container_for_frame( frame_title )
	_if ( item << container.get_items( id_path ).an_element()) _is _unset
	_then 
		item << _self.get_item( id_path )
	_endif
	
	state << item.enabled?
	fail_string << write_string("Expected State of ", item, " is ", expected_state, " but it is ", state)
	_self.assert_equals(expected_state, state, fail_string)

	>> _self
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_pulldown_menu_has_labels(include_labels)
	##
	## Checks if the pulldown menu in .properties[:pulldown_menu]
	## has child items with the strings in INCLUDE_LABELS

	fail_str << write_string("Pulldown menu missing items")

	missing_labels? << _false
	actual_labels << rope.new()
	# The pulldown menu may contain extra controls in addition to the labels (each of
	# which belongs to a sw_menu_button_item) for example extra buttons so we need
	# to only look at sw_menu_button_items
	# The pulldown_menu property is an instance of pulldown_menu so we need to look
	# in its swift container for its child sw_menu_button_items.
	pulldown_menu_container << _self.properties[:pulldown_menu].children_container
	_for i_item _over pulldown_menu_container.get_items_of_type( :tag!sw_menu_button_item ).fast_elements()
	_loop
		actual_labels.add_last(i_item.label)
	_endloop

	_for i_label _over include_labels.fast_elements()
	_loop
		missing_labels? << _not actual_labels.includes_by_equality?(i_label)

		_if missing_labels?
		_then
			_leave
		_endif
	_endloop 
	
	_self.assert_false(missing_labels?, fail_str)

	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_pulldown_menu_doesnt_have_labels(exclude_labels)
	##
	## Checks if the pulldown menu in .properties[:pulldown_menu]
	## doesn't have child items with the strings in EXCLUDE_LABELS

	fail_str << write_string("Pulldown menu has extra items")

	has_labels? << _false
	
	_for i_item _over _self.properties[:pulldown_menu].children.fast_elements()
	_loop
		has_labels? << exclude_labels.includes_by_equality?(i_item.label)

		_if has_labels?
		_then
			_leave
		_endif 
	_endloop 

	_self.assert_false(has_labels?, fail_str)

	>> _self
	
_endmethod
$



_pragma(classify_level=debug)
_method application_system_test_mixin.scenario_insert_record( dataset_name, collection_name, proposed_values, expected_values )
	## 
	##
	
	>> _self.given_an_embbeded_editor_with_default_values( dataset_name, collection_name ).
		given_proposed_editor_values( proposed_values ).
		
		when_inserting_record().
		when_going_to_inserted_record().

		then_record_is_shown_on_map( _self.parameter_new_record() ).
		then_editor_label_is( _self.parameter_editor_label_inserted() ).
		then_editor_fields_display( expected_values )	
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_new_record()
	## 
	## 

	>> _self.properties[:new_record]
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.wait_for_application_to_be_active( app_name )
	## 
	##
	_for i _over 1.upto(10)
	_loop
		_if (app << smallworld_product.application(app_name)) _isnt _unset _andif
		    app.active?
		_then
			write(write_string("Attempt ",i," successfull - application ",app_name, "is running. Starting test: ",_self.get_name()))
			#We've started.
			_self.properties[ :application ] << app
			_self.wait_for_application_threads_to_finish()
			_leave
		_endif
		_thisthread.sleep(5000)
	_endloop	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.dataset( ds_name )
	##
	## Returns the dataset named DS_NAME
	##

	>> gis_program_manager.databases[ds_name]
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.click_action_button( action,
								    _optional container, new_frame_wait_time )
	## 
	## Look through all the sw_button_items on the application's
	## top container that has :model = ACTION.  Click on the first
	## one found.
	##

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif
	
	_for item _over container.all_items()
	_loop
		
		_if ( model << item.model ) = action _orif
		    ( model.is_kind_of?( toolbar_action_proxy ) _andif
		      model.real_subject = action )
		_then
			button << item
			_leave 
		_endif
		
	_endloop

	_self.properties[ :action_button ] << button
	_self.click_item( button, property_list.new_with(:new_frame_wait_time, new_frame_wait_time) )

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.click_item( item, _optional props )
	##
	## Click on ITEM
	##
	## PROPS is a property list of optional properties. Valid keys are:
	##
	## :new_frame_wait_time - time to wait for new frame to be activated (if
	## clicking the item is expected to activate a new frame)
	## :x - click location x coord - defaults to middle of ITEM
	## :y - click location y coord - defaults to middle of ITEM
	## :message_dialog_wait_id - indicates clicking item will invoke a message
	##                  dialog. Identifier can be used later to wait for dialog to
	##                  be closed. 
	##

	_if props _isnt _unset
	_then	
		new_frame_wait_time << props[:new_frame_wait_time]
		x << props[:x]
		y << props[:y]
		message_dialog_wait_id << props[:message_dialog_wait_id]
	_endif

	_self.properties[ :click_item ] << item

	_if x _is _unset
	_then
		x << ( item.width  / 2.0 ).rounded
	_endif
	_if y _is _unset
	_then
		y << ( item.height / 2.0 ).rounded
	_endif

	top_container << item.top_container
	(top_x, top_y) << item.location_in_window( top_container )
	
	x +<< top_x
	y +<< top_y

	_self.handle_event( top_container, :locator, :move, x, y, _unset, _unset )
	_self.handle_event( top_container, :button, :left, x, y, :press, 0 )

	_if new_frame_wait_time _isnt _unset _orif message_dialog_wait_id _isnt _unset
	_then
		_self.remove_value_from_queue( :frame_active )
		frame.add_dependent( _self, :frame_active )
	_endif
	
	_self.handle_event( top_container, :button, :left, x, y, :release, 0, _unset, message_dialog_wait_id )

	_if new_frame_wait_time _isnt _unset _orif message_dialog_wait_id _isnt _unset
	_then
		_self.wait_for_value_on_queue( :frame_active, _false, new_frame_wait_time )
		frame.remove_dependent( _self )
	_endif
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.handle_event( a_canvas, category, id, x, y, func, modmask,
							     _optional second_id, message_dialog_wait_id )
	## 
	##

	a_canvas.add_dependent( _self )

	(s, m) << system.time_now()
	time << s * 1000 + m
	new_event << input_event.new_with( category, time, a_canvas.actual.id, id, x, y, func, modmask )
	new_event.second_id << second_id

	_if category _is :locator _andif
	    id _is :move _andif 
	    _not a_canvas.has_focus?
	_then
		a_canvas.top_frame.activate()
		_self.wait_for_event_on_queue( :event_handled, :visible )
	_endif

	_if message_dialog_wait_id _is _unset
	_then
		a_canvas.handle_event( new_event )

		_self.wait_for_event_on_queue( :event_handled, id )

		a_canvas.remove_dependent( _self )
	_else
		app << _self.properties[ :application ]
		task << app.do_work(a_canvas, :|handle_event()|, new_event)
		_self.properties[ message_dialog_wait_id ] << {task, a_canvas, id}
	_endif
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.map_manager
	## 
	## 

	>> _self.properties[ :application ].get_service_provider( :map_manager )
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.editor_manager
	## 
	## 

	>> _self.properties[ :application ].get_service_provider( :editor_manager )
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.parameter_unique_id_string( id, prefix )
	## 
	## Set the .properties[ ID ] to "PREFIX" +
	## system.elapsed_seconds()
	##

	_if _self.properties[ id ] _is _unset
	_then 
		_self.properties[ id ] << write_string( prefix, system.elapsed_seconds().as_fixed_string( 10, 10 ))
	_endif

	>> _self.properties[ id ]
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_editor_label_inserted()
	## 
	## Return a string with the expected string for the editor when
	## a record is inserted.
	##
	## This is based on the current record:
	## [<dataset_name>] <collection_name> - record inserted
	##

	>> write_string( _self.editor_label(), " - record inserted" )
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_editor_label_updated()
	## 
	## Return a string with the expected string for the editor when
	## a record is updated.
	##
	## This is based on the current record:
	## [<dataset_name>] <collection_name> - record updated
	##

	>> write_string( _self.editor_label(), " - record updated" )
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.editor_label()
	## 
	##
	
	record << _self.parameter_new_record()
	label  << write_string( "[", record.source_view.external_name, "] ", record.external_name )

	>> label 
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_pulldown_menu_container
	## 
	##

	_if ( menu << _self.properties[ :pulldown_menu ] ) _isnt _unset
	_then
		_return menu.top_container
	_endif
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.insert_action()
	## 
	## Return the insert action on the editor.
	##
	## This is the action named :insert
	##
	
	>> _self.properties[ :editor ].action( :insert )
	
_endmethod
$

_pragma(classify_level=debug)
_private _method application_system_test_mixin.close_dialogs()
	## 
	## Close any dialogs that are listed in the properties
	## [:dialogs ] slot
	##

	dialogs << _self.properties[ :dialogs ]
	_if dialogs _isnt _unset
	_then
		_for dialog _over dialogs.elements()
		_loop
			dialog.close()
		_endloop
	_endif 
	
_endmethod
$

_pragma(classify_level=debug)
_private _method application_system_test_mixin.add_dialog( a_dialog )
	## 
	## Add A_DIALOG to the properties
	## [:dialogs ] slot
	##

	_if _self.properties[ :dialogs ] _is _unset
	_then 
		_self.properties[ :dialogs ] << rope.new()
	_endif 

	_if a_dialog _isnt _unset
	_then 
		_self.properties[ :dialogs ].add( a_dialog )
	_endif 
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method application_system_test_mixin.wait_for_threads_to_finish( task_owner )
	## 
	## Wait for all the tasks on TASK_OWNER to finish.
	##
	## Wait for 1 second and check if TASK_OWNER.thread_pool is
	## empty.
	##

	_loop
		_if task_owner.task_runner().thread_pool.empty? _then _leave _endif
		_thisthread.sleep( 1000 )
	_endloop 
	
_endmethod
$

_private _method application_system_test_mixin.wait_for_application_threads_to_finish()
	
	_if (a_task_owner<< _self.properties[ :application ]) _isnt _unset
	_then 
		_self.wait_for_threads_to_finish( a_task_owner )
		_if (a_task_owner<< a_task_owner.top_frame) _isnt _unset _andif
		    (a_task_owner<< a_task_owner.top_canvas_container) _isnt _unset
		_then 
			_self.wait_for_threads_to_finish( a_task_owner )
		_endif 
	_endif
_endmethod 
$


_pragma(classify_level=debug)
_method application_system_test_mixin.get_components( _optional a_string, a_component, module_name )
	## 
	## Returns a rope of components with a name or class name
	## matching A_STRING in the component A_COMPONENT.
	##
	## All open applications will be searched if A_COMPONENT is not
	## provided.
	## All components will be returned if A_STRING is not provided.
	##
	## If MODULE_NAME is provided the results are restricted to
	## modules matching that name.
	##
	## Example of use (with PNI user app open):
	##  get_components("editor")
	##    1    a topology_editor_plugin(topology)
	##    2    a editor_activator_pi(editor_activator)
	##    3    a pni_editor_manager(editor_manager)
	##    4    a editor_viewer(embedded_viewer)
	##    5    a pni_editor_manager(editor_manager)
	##    sw:rope:[1-5]
	##
	##  get_components("con menu")
	##    1    a connectivity_menu_plugin(connectivity_menu)
	##    2    a connectivity_menu_framework(connectivity_menu)
	##    sw:rope:[1-2]
	##
	##  get_components("app man")
	##    1    a pni_application_manager(application_manager)
	##    sw:rope:[1-1]
	##
	##  Return all components of the PNI application:
	##  app << smallworld_product.application(:pni)
	##  get_components( _unset, app )
	##

	test_string << _proc( a_string )

			       _if a_string _is _unset
			       _then
				       _return
			       _endif
			       
			       _for i, c _over a_string.fast_keys_and_elements()
			       _loop
				       _if c _is %space
				       _then
					       a_string[i] << %*
				       _endif
			       _endloop
			       
			       end << a_string.size
			       
			       a_stream << internal_text_output_stream.new()
			       _if a_string[1] _is %^
			       _then
				       start << 2
			       _else
				       a_stream.put( %* )
				       start << 1
			       _endif
			       _if a_string[end] _is %$
			       _then
				       a_stream.write( a_string.slice(start, end - 1) )
			       _else
				       a_stream.write( a_string.slice(start, end) )
				       a_stream.put( %* )
			       _endif
			       
			       _return a_stream.string
		       _endproc

	a_string << test_string( a_string )
	module_name << test_string( module_name )
	
	results << rope.new()
	done << set.new()

	a_queue << queue.new()

	_if a_component _isnt _unset
	_then
		a_queue.add( a_component )
		done.add( a_component )
	_else
		_for app _over smallworld_product.applications.fast_elements()
		_loop
			a_queue.add( app )
			done.add( app )
		_endloop
	_endif
	
	types << property_list.new_with( :gui, _false )

	_loop
		_if a_queue.empty? _then _leave _endif
		
		c << a_queue.next()

		_if ( a_string _is _unset _orif
		      c.class_name.write_string.matches?( a_string ) _orif
		      ( c.responds_to?( :name ) _andif
			c.name _isnt _unset _andif
			c.name.write_string.matches?( a_string ) ) ) _andif
		    ( module_name _is _unset _orif
		      c.module_name.write_string.matches?( module_name ) )
		_then
			results.add_last( c )
		_endif
		
		rel_items << _self.get_related_items( c, types )
		
		_for r _over rel_items.fast_elements()
		_loop
			_if _not done.includes?( r )
			_then
				a_queue.add( r )
				done.add( r )
			_endif
		_endloop
	_endloop
	
	>> results
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.get_related_items( obj, _optional types )
	## 
	## Returns a set of objects related to the object OBJ.
	##
	## TYPES controls what relationships are considered and should
	## be a property list with relationship name and boolean pairs.
	## By default all types are included.
	##
	## Supported relationships are:
	##  :slots
	##  :components
	##  :framework
	##  :dialogs
	##  :gui
	##  :gui_owner
	##  :dependents
	##  :action_engine
	##
	## Example of use:
	##  app << smallworld_product.applications.an_element()
	##  get_related_items( app, property_list.new_with(:gui, _false) )
	##

	_if types _is _unset
	_then
		types << property_list.new()
	_endif
	
	others << set.new()

	gui? << types[:gui] _isnt _false
	
	_if types[:slots] _isnt _false _andif
	    obj.responds_to?( :|sys!slot_names_and_values()| )
	_then
		obj_mod_name << obj.module_name
		_for slot_name, slot_value _over obj.sys!slot_names_and_values()
		_loop
			_if slot_value.is_kind_of?( sw_component ) _orif
			    ( gui? _andif slot_value.responds_to?( :|tag!sw_item_base| ) ) _orif
			    slot_value.module_name _is obj_mod_name
			_then
				others.add( slot_value )
			_endif
		_endloop
	_endif

	_if types[:components] _isnt _false _andif
	    obj.responds_to?( :components|()| )
	_then
		_for c _over obj.components()
		_loop
			others.add( c )
		_endloop
	_endif
	
	_if types[:framework] _is _true _andif
	    obj.responds_to?( :framework ) _andif
	    obj.framework _isnt _unset
	_then
		others.add( obj.framework )
	_endif
	
	_if types[:dialogs] _isnt _false _andif
	    ( obj.is_kind_of?( gui_framework ) _orif
	      obj.is_kind_of?( plugin ) )
	_then
		_for name, a_dialog _over obj.sys!slot(:dialogs).fast_keys_and_elements()
		_loop
			_if a_dialog _isnt _unset
			_then
				others.add( a_dialog )
			_endif
		_endloop
	_endif
	
	_if types[:dependents] _isnt _false
	_then
		_for d _over obj.dependents()
		_loop
			_if d.is_kind_of?( sw_component ) _orif
			    ( gui? _andif d.responds_to?( :|tag!sw_item_base| ) )
			_then
				others.add( d )
			_endif
		_endloop
	_endif
	
	_if types[:action_engine] _isnt _false _andif
	    obj.responds_to?( :|tag!sw_item_base| )
	_then
		_if ( a_model << obj.model ) _isnt _unset
		_then
			others.add( a_model )
			_if a_model.is_kind_of?( sw_action ) _andif
			    ( an_engine << a_model.engine ) _isnt _unset
			_then
				others.add( an_engine )
			_endif
		_endif
	_endif

	_if types[:gui_owner] _isnt _false _andif
	    obj.responds_to?( :|tag!sw_item_base| ) _andif
	    obj.responds_to?( :|get_gui_owner()| ) _andif
	    ( owner << obj.get_gui_owner() ) _isnt _unset
	_then
		others.add( owner )
	_endif
	
	>> others
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.container_for_frame(_optional frame_title)
	## 
	## Return the top_canvas_container of the active frame with
	## title FRAME_TITLE. 
	##
	## If this is not supplied, return the
	## .properties[:application]'s top frame's top_canvas_container.
	##
	## This method can return unset
	##

	_if _self.properties[ :application ] _isnt _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif
	
	_if frame_title _isnt _unset
	_then
		_for top_container _over sw_swift_manager.active_top_containers().fast_elements()
		_loop
			_if top_container.top_frame.title = frame_title
			_then
				container << top_container
				_leave
			_endif
		_endloop
	_endif

	>> container
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_waiting_for_message_dialog_invocation_to_complete( message_dialog_wait_id )
	## 
	##
	wait_data << _self.properties[ message_dialog_wait_id ]

	_if wait_data _isnt _unset
	_then
		(task, a_canvas, id) << (_scatter wait_data)
		
		task.get_results()
		
		_self.wait_for_event_on_queue( :event_handled, id )
		
		a_canvas.remove_dependent( _self )
	_else
		write("No data stored for message_dialog_wait_id: ", message_dialog_wait_id)
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_label_item_with_identifier_has_value(identifier, expected_value,
									       _optional frame_title)
	## 
	## Check a Swift widget's VALUE.
	##
	## IDENTIFIER is the identifier of the widget to check.
	##
	## EXPECTED_TEXT is the expected string value for the Swift
	## widget.
	##
	## FRAME_TITLE if supplied is the title of the frame on which
	## to look for the widget.
	##
	
	>> _self.then_item_with_identifier_has_value(:tag!sw_label_item, identifier, expected_value, frame_title)
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_text_item_with_identifier_has_value(identifier, expected_value,
									       _optional frame_title)
	## 
	## Check a Swift widget's VALUE.
	##
	## IDENTIFIER is the identifier of the widget to check.
	##
	## EXPECTED_TEXT is the expected string value for the Swift
	## widget.
	##
	## FRAME_TITLE if supplied is the title of the frame on which
	## to look for the widget.
	##
	
	>> _self.then_item_with_identifier_has_value(:tag!sw_text_item, identifier, expected_value, frame_title)
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_item_with_identifier_has_value(tag, identifier, expected_value,
									  _optional frame_title)
	## 
	## Check a Swift widget's VALUE.
	##
	## IDENTIFIER is the identifier of the widget to check.
	##
	## EXPECTED_TEXT is the expected string value for the Swift
	## widget.
	##
	## FRAME_TITLE if supplied is the title of the frame on which
	## to look for the widget.
	##
	
	item << _self.get_item_with_identifier(tag, identifier, :frame_title, frame_title)

	_self.assert_not_unset(item, write_string("Failed to find component with identifier ", identifier))
	_if item _isnt _unset
	_then
		fail_str << write_string("Expected the value of the text item ", identifier, " to be ", expected_value,
					 ", but it is ", item.value)
		_self.assert_equals(expected_value, item.value, fail_str)
	_endif
	
	>> _self
	
_endmethod
$

_pragma(classify_level=restricted, topic={munit})
_method application_system_test_mixin.then_styled_string_is( tree_id_or_path, a_string,
							     expected_ss )
	##
	## Assert that the styled string for a display_tree represented by A_STRING in a
	## tree_item matches EXPECTED_SS
	##
	## TREE_ID_OR_PATH can be the tree_item id or its identifier
	## path or the path of a container of the tree_item.
	##
	## If the display_tree cannot be found, get_display_tree() will fail so no point
	## in continuing
	##

	dt       << _self.get_display_tree( tree_id_or_path, a_string )
	_if dt _is _unset
	_then
		_return
	_endif

	actual   << rope.new_from_iter( dt.styled_string, :|fast_elements()| )
	expected << rope.new_from_iter( expected_ss, :|fast_elements()| )
	fail_str << "styled_string element mismatch at"
	_self.assert_deep_equals( expected, actual, fail_str )
	
	>> _self
	
_endmethod
$
